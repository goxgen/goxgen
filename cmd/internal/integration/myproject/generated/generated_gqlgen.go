// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Action                  func(ctx context.Context, obj interface{}, next graphql.Resolver, resource string, action XgenResourceActionType, route *string, schemaFieldName *string) (res interface{}, err error)
	ActionField             func(ctx context.Context, obj interface{}, next graphql.Resolver, label *string, description *string, mapTo []string) (res interface{}, err error)
	ExcludeArgumentFromType func(ctx context.Context, obj interface{}, next graphql.Resolver, exclude *bool) (res interface{}, err error)
	Field                   func(ctx context.Context, obj interface{}, next graphql.Resolver, label *string, description *string, db *XgenResourceFieldDbConfigInput) (res interface{}, err error)
	ListAction              func(ctx context.Context, obj interface{}, next graphql.Resolver, resource string, action XgenResourceListActionType, route *string, pagination *bool, schemaFieldName *string) (res interface{}, err error)
	Resource                func(ctx context.Context, obj interface{}, next graphql.Resolver, name string, route *string, primary *bool, db *XgenResourceDbConfigInput) (res interface{}, err error)
	XgenCustomConf          func(ctx context.Context, obj interface{}, next graphql.Resolver, asd *string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Action struct {
		Action          func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	ActionAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ActionField struct {
		Description func(childComplexity int) int
		Label       func(childComplexity int) int
		MapTo       func(childComplexity int) int
	}

	CustomTodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	DeleteTodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Field struct {
		Description func(childComplexity int) int
		Label       func(childComplexity int) int
	}

	ListAction struct {
		Action          func(childComplexity int) int
		Pagination      func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	ListActionAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ListTodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Mutation struct {
		NewTodo    func(childComplexity int, input *NewTodo) int
		TodoCustom func(childComplexity int, input *CustomTodo) int
		TodoDelete func(childComplexity int, input *DeleteTodo) int
		TodoUpdate func(childComplexity int, input *UpdateTodo) int
		UserCreate func(childComplexity int, input *NewUser) int
		UserUpdate func(childComplexity int, input *UpdateUser) int
	}

	NewTodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	NewUserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Query struct {
		TodoBrowse        func(childComplexity int, where *ListTodo, pagination *XgenPaginationInput) int
		UserBrowse        func(childComplexity int, where *UserList, pagination *XgenPaginationInput) int
		XgenIntrospection func(childComplexity int) int
	}

	Resource struct {
		Name    func(childComplexity int) int
		Primary func(childComplexity int) int
		Route   func(childComplexity int) int
	}

	ResourceAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Todo struct {
		Done func(childComplexity int) int
		ID   func(childComplexity int) int
		Text func(childComplexity int) int
		User func(childComplexity int) int
	}

	TodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	UpdateTodoXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	UpdateUserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	User struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	UserListXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	UserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenAnnotationMap struct {
		Action     func(childComplexity int) int
		ListAction func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenCursorPaginationInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenFieldDef struct {
		ActionField func(childComplexity int) int
		Field       func(childComplexity int) int
	}

	XgenIntrospection struct {
		Annotation func(childComplexity int) int
		Object     func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenObjectDefinition struct {
		Action     func(childComplexity int) int
		ListAction func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenObjectField struct {
		Definition func(childComplexity int) int
		Name       func(childComplexity int) int
	}

	XgenObjectMap struct {
		CustomTodo                     func(childComplexity int) int
		DeleteTodo                     func(childComplexity int) int
		ListTodo                       func(childComplexity int) int
		NewTodo                        func(childComplexity int) int
		NewUser                        func(childComplexity int) int
		Todo                           func(childComplexity int) int
		UpdateTodo                     func(childComplexity int) int
		UpdateUser                     func(childComplexity int) int
		User                           func(childComplexity int) int
		UserList                       func(childComplexity int) int
		XgenCursorPaginationInput      func(childComplexity int) int
		XgenPaginationInput            func(childComplexity int) int
		XgenResourceActionType         func(childComplexity int) int
		XgenResourceDbConfigInput      func(childComplexity int) int
		XgenResourceFieldDbConfigInput func(childComplexity int) int
		XgenResourceListActionType     func(childComplexity int) int
	}

	XgenPaginationInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceAction struct {
		Action          func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	XgenResourceActionTypeXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceDbConfigInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceDefinition struct {
		Actions    func(childComplexity int) int
		ObjectName func(childComplexity int) int
		Properties func(childComplexity int) int
	}

	XgenResourceFieldDbConfigInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceListActionTypeXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceMap struct {
		Todo func(childComplexity int) int
		User func(childComplexity int) int
	}

	XgenResourceProperty struct {
		Name    func(childComplexity int) int
		Primary func(childComplexity int) int
		Route   func(childComplexity int) int
	}
}

type MutationResolver interface {
	TodoDelete(ctx context.Context, input *DeleteTodo) (*Todo, error)
	TodoCustom(ctx context.Context, input *CustomTodo) (*Todo, error)
	UserCreate(ctx context.Context, input *NewUser) (*User, error)
	UserUpdate(ctx context.Context, input *UpdateUser) (*User, error)
	NewTodo(ctx context.Context, input *NewTodo) (*Todo, error)
	TodoUpdate(ctx context.Context, input *UpdateTodo) (*Todo, error)
}
type QueryResolver interface {
	XgenIntrospection(ctx context.Context) (*XgenIntrospection, error)
	UserBrowse(ctx context.Context, where *UserList, pagination *XgenPaginationInput) ([]*User, error)
	TodoBrowse(ctx context.Context, where *ListTodo, pagination *XgenPaginationInput) ([]*Todo, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Action.Action":
		if e.complexity.Action.Action == nil {
			break
		}

		return e.complexity.Action.Action(childComplexity), true

	case "Action.Resource":
		if e.complexity.Action.Resource == nil {
			break
		}

		return e.complexity.Action.Resource(childComplexity), true

	case "Action.Route":
		if e.complexity.Action.Route == nil {
			break
		}

		return e.complexity.Action.Route(childComplexity), true

	case "Action.SchemaFieldName":
		if e.complexity.Action.SchemaFieldName == nil {
			break
		}

		return e.complexity.Action.SchemaFieldName(childComplexity), true

	case "ActionAnnotationSingle.name":
		if e.complexity.ActionAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ActionAnnotationSingle.Name(childComplexity), true

	case "ActionAnnotationSingle.value":
		if e.complexity.ActionAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ActionAnnotationSingle.Value(childComplexity), true

	case "ActionField.Description":
		if e.complexity.ActionField.Description == nil {
			break
		}

		return e.complexity.ActionField.Description(childComplexity), true

	case "ActionField.Label":
		if e.complexity.ActionField.Label == nil {
			break
		}

		return e.complexity.ActionField.Label(childComplexity), true

	case "ActionField.MapTo":
		if e.complexity.ActionField.MapTo == nil {
			break
		}

		return e.complexity.ActionField.MapTo(childComplexity), true

	case "CustomTodoXgenDef.field":
		if e.complexity.CustomTodoXgenDef.Field == nil {
			break
		}

		return e.complexity.CustomTodoXgenDef.Field(childComplexity), true

	case "CustomTodoXgenDef.object":
		if e.complexity.CustomTodoXgenDef.Object == nil {
			break
		}

		return e.complexity.CustomTodoXgenDef.Object(childComplexity), true

	case "DeleteTodoXgenDef.field":
		if e.complexity.DeleteTodoXgenDef.Field == nil {
			break
		}

		return e.complexity.DeleteTodoXgenDef.Field(childComplexity), true

	case "DeleteTodoXgenDef.object":
		if e.complexity.DeleteTodoXgenDef.Object == nil {
			break
		}

		return e.complexity.DeleteTodoXgenDef.Object(childComplexity), true

	case "Field.Description":
		if e.complexity.Field.Description == nil {
			break
		}

		return e.complexity.Field.Description(childComplexity), true

	case "Field.Label":
		if e.complexity.Field.Label == nil {
			break
		}

		return e.complexity.Field.Label(childComplexity), true

	case "ListAction.Action":
		if e.complexity.ListAction.Action == nil {
			break
		}

		return e.complexity.ListAction.Action(childComplexity), true

	case "ListAction.Pagination":
		if e.complexity.ListAction.Pagination == nil {
			break
		}

		return e.complexity.ListAction.Pagination(childComplexity), true

	case "ListAction.Resource":
		if e.complexity.ListAction.Resource == nil {
			break
		}

		return e.complexity.ListAction.Resource(childComplexity), true

	case "ListAction.Route":
		if e.complexity.ListAction.Route == nil {
			break
		}

		return e.complexity.ListAction.Route(childComplexity), true

	case "ListAction.SchemaFieldName":
		if e.complexity.ListAction.SchemaFieldName == nil {
			break
		}

		return e.complexity.ListAction.SchemaFieldName(childComplexity), true

	case "ListActionAnnotationSingle.name":
		if e.complexity.ListActionAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ListActionAnnotationSingle.Name(childComplexity), true

	case "ListActionAnnotationSingle.value":
		if e.complexity.ListActionAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ListActionAnnotationSingle.Value(childComplexity), true

	case "ListTodoXgenDef.field":
		if e.complexity.ListTodoXgenDef.Field == nil {
			break
		}

		return e.complexity.ListTodoXgenDef.Field(childComplexity), true

	case "ListTodoXgenDef.object":
		if e.complexity.ListTodoXgenDef.Object == nil {
			break
		}

		return e.complexity.ListTodoXgenDef.Object(childComplexity), true

	case "Mutation.new_todo":
		if e.complexity.Mutation.NewTodo == nil {
			break
		}

		args, err := ec.field_Mutation_new_todo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewTodo(childComplexity, args["input"].(*NewTodo)), true

	case "Mutation.todo_custom":
		if e.complexity.Mutation.TodoCustom == nil {
			break
		}

		args, err := ec.field_Mutation_todo_custom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TodoCustom(childComplexity, args["input"].(*CustomTodo)), true

	case "Mutation.todo_delete":
		if e.complexity.Mutation.TodoDelete == nil {
			break
		}

		args, err := ec.field_Mutation_todo_delete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TodoDelete(childComplexity, args["input"].(*DeleteTodo)), true

	case "Mutation.todo_update":
		if e.complexity.Mutation.TodoUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_todo_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TodoUpdate(childComplexity, args["input"].(*UpdateTodo)), true

	case "Mutation.user_create":
		if e.complexity.Mutation.UserCreate == nil {
			break
		}

		args, err := ec.field_Mutation_user_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserCreate(childComplexity, args["input"].(*NewUser)), true

	case "Mutation.user_update":
		if e.complexity.Mutation.UserUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_user_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdate(childComplexity, args["input"].(*UpdateUser)), true

	case "NewTodoXgenDef.field":
		if e.complexity.NewTodoXgenDef.Field == nil {
			break
		}

		return e.complexity.NewTodoXgenDef.Field(childComplexity), true

	case "NewTodoXgenDef.object":
		if e.complexity.NewTodoXgenDef.Object == nil {
			break
		}

		return e.complexity.NewTodoXgenDef.Object(childComplexity), true

	case "NewUserXgenDef.field":
		if e.complexity.NewUserXgenDef.Field == nil {
			break
		}

		return e.complexity.NewUserXgenDef.Field(childComplexity), true

	case "NewUserXgenDef.object":
		if e.complexity.NewUserXgenDef.Object == nil {
			break
		}

		return e.complexity.NewUserXgenDef.Object(childComplexity), true

	case "Query.todo_browse":
		if e.complexity.Query.TodoBrowse == nil {
			break
		}

		args, err := ec.field_Query_todo_browse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TodoBrowse(childComplexity, args["where"].(*ListTodo), args["pagination"].(*XgenPaginationInput)), true

	case "Query.user_browse":
		if e.complexity.Query.UserBrowse == nil {
			break
		}

		args, err := ec.field_Query_user_browse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserBrowse(childComplexity, args["where"].(*UserList), args["pagination"].(*XgenPaginationInput)), true

	case "Query._xgen_introspection":
		if e.complexity.Query.XgenIntrospection == nil {
			break
		}

		return e.complexity.Query.XgenIntrospection(childComplexity), true

	case "Resource.Name":
		if e.complexity.Resource.Name == nil {
			break
		}

		return e.complexity.Resource.Name(childComplexity), true

	case "Resource.Primary":
		if e.complexity.Resource.Primary == nil {
			break
		}

		return e.complexity.Resource.Primary(childComplexity), true

	case "Resource.Route":
		if e.complexity.Resource.Route == nil {
			break
		}

		return e.complexity.Resource.Route(childComplexity), true

	case "ResourceAnnotationSingle.name":
		if e.complexity.ResourceAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ResourceAnnotationSingle.Name(childComplexity), true

	case "ResourceAnnotationSingle.value":
		if e.complexity.ResourceAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ResourceAnnotationSingle.Value(childComplexity), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.text":
		if e.complexity.Todo.Text == nil {
			break
		}

		return e.complexity.Todo.Text(childComplexity), true

	case "Todo.user":
		if e.complexity.Todo.User == nil {
			break
		}

		return e.complexity.Todo.User(childComplexity), true

	case "TodoXgenDef.field":
		if e.complexity.TodoXgenDef.Field == nil {
			break
		}

		return e.complexity.TodoXgenDef.Field(childComplexity), true

	case "TodoXgenDef.object":
		if e.complexity.TodoXgenDef.Object == nil {
			break
		}

		return e.complexity.TodoXgenDef.Object(childComplexity), true

	case "UpdateTodoXgenDef.field":
		if e.complexity.UpdateTodoXgenDef.Field == nil {
			break
		}

		return e.complexity.UpdateTodoXgenDef.Field(childComplexity), true

	case "UpdateTodoXgenDef.object":
		if e.complexity.UpdateTodoXgenDef.Object == nil {
			break
		}

		return e.complexity.UpdateTodoXgenDef.Object(childComplexity), true

	case "UpdateUserXgenDef.field":
		if e.complexity.UpdateUserXgenDef.Field == nil {
			break
		}

		return e.complexity.UpdateUserXgenDef.Field(childComplexity), true

	case "UpdateUserXgenDef.object":
		if e.complexity.UpdateUserXgenDef.Object == nil {
			break
		}

		return e.complexity.UpdateUserXgenDef.Object(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "UserListXgenDef.field":
		if e.complexity.UserListXgenDef.Field == nil {
			break
		}

		return e.complexity.UserListXgenDef.Field(childComplexity), true

	case "UserListXgenDef.object":
		if e.complexity.UserListXgenDef.Object == nil {
			break
		}

		return e.complexity.UserListXgenDef.Object(childComplexity), true

	case "UserXgenDef.field":
		if e.complexity.UserXgenDef.Field == nil {
			break
		}

		return e.complexity.UserXgenDef.Field(childComplexity), true

	case "UserXgenDef.object":
		if e.complexity.UserXgenDef.Object == nil {
			break
		}

		return e.complexity.UserXgenDef.Object(childComplexity), true

	case "XgenAnnotationMap.Action":
		if e.complexity.XgenAnnotationMap.Action == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.Action(childComplexity), true

	case "XgenAnnotationMap.ListAction":
		if e.complexity.XgenAnnotationMap.ListAction == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.ListAction(childComplexity), true

	case "XgenAnnotationMap.Resource":
		if e.complexity.XgenAnnotationMap.Resource == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.Resource(childComplexity), true

	case "XgenCursorPaginationInputXgenDef.field":
		if e.complexity.XgenCursorPaginationInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenCursorPaginationInputXgenDef.Field(childComplexity), true

	case "XgenCursorPaginationInputXgenDef.object":
		if e.complexity.XgenCursorPaginationInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenCursorPaginationInputXgenDef.Object(childComplexity), true

	case "XgenFieldDef.ActionField":
		if e.complexity.XgenFieldDef.ActionField == nil {
			break
		}

		return e.complexity.XgenFieldDef.ActionField(childComplexity), true

	case "XgenFieldDef.Field":
		if e.complexity.XgenFieldDef.Field == nil {
			break
		}

		return e.complexity.XgenFieldDef.Field(childComplexity), true

	case "XgenIntrospection.annotation":
		if e.complexity.XgenIntrospection.Annotation == nil {
			break
		}

		return e.complexity.XgenIntrospection.Annotation(childComplexity), true

	case "XgenIntrospection.object":
		if e.complexity.XgenIntrospection.Object == nil {
			break
		}

		return e.complexity.XgenIntrospection.Object(childComplexity), true

	case "XgenIntrospection.resource":
		if e.complexity.XgenIntrospection.Resource == nil {
			break
		}

		return e.complexity.XgenIntrospection.Resource(childComplexity), true

	case "XgenObjectDefinition.Action":
		if e.complexity.XgenObjectDefinition.Action == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.Action(childComplexity), true

	case "XgenObjectDefinition.ListAction":
		if e.complexity.XgenObjectDefinition.ListAction == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.ListAction(childComplexity), true

	case "XgenObjectDefinition.Resource":
		if e.complexity.XgenObjectDefinition.Resource == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.Resource(childComplexity), true

	case "XgenObjectField.definition":
		if e.complexity.XgenObjectField.Definition == nil {
			break
		}

		return e.complexity.XgenObjectField.Definition(childComplexity), true

	case "XgenObjectField.name":
		if e.complexity.XgenObjectField.Name == nil {
			break
		}

		return e.complexity.XgenObjectField.Name(childComplexity), true

	case "XgenObjectMap.CustomTodo":
		if e.complexity.XgenObjectMap.CustomTodo == nil {
			break
		}

		return e.complexity.XgenObjectMap.CustomTodo(childComplexity), true

	case "XgenObjectMap.DeleteTodo":
		if e.complexity.XgenObjectMap.DeleteTodo == nil {
			break
		}

		return e.complexity.XgenObjectMap.DeleteTodo(childComplexity), true

	case "XgenObjectMap.ListTodo":
		if e.complexity.XgenObjectMap.ListTodo == nil {
			break
		}

		return e.complexity.XgenObjectMap.ListTodo(childComplexity), true

	case "XgenObjectMap.NewTodo":
		if e.complexity.XgenObjectMap.NewTodo == nil {
			break
		}

		return e.complexity.XgenObjectMap.NewTodo(childComplexity), true

	case "XgenObjectMap.NewUser":
		if e.complexity.XgenObjectMap.NewUser == nil {
			break
		}

		return e.complexity.XgenObjectMap.NewUser(childComplexity), true

	case "XgenObjectMap.Todo":
		if e.complexity.XgenObjectMap.Todo == nil {
			break
		}

		return e.complexity.XgenObjectMap.Todo(childComplexity), true

	case "XgenObjectMap.UpdateTodo":
		if e.complexity.XgenObjectMap.UpdateTodo == nil {
			break
		}

		return e.complexity.XgenObjectMap.UpdateTodo(childComplexity), true

	case "XgenObjectMap.UpdateUser":
		if e.complexity.XgenObjectMap.UpdateUser == nil {
			break
		}

		return e.complexity.XgenObjectMap.UpdateUser(childComplexity), true

	case "XgenObjectMap.User":
		if e.complexity.XgenObjectMap.User == nil {
			break
		}

		return e.complexity.XgenObjectMap.User(childComplexity), true

	case "XgenObjectMap.UserList":
		if e.complexity.XgenObjectMap.UserList == nil {
			break
		}

		return e.complexity.XgenObjectMap.UserList(childComplexity), true

	case "XgenObjectMap.XgenCursorPaginationInput":
		if e.complexity.XgenObjectMap.XgenCursorPaginationInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenCursorPaginationInput(childComplexity), true

	case "XgenObjectMap.XgenPaginationInput":
		if e.complexity.XgenObjectMap.XgenPaginationInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenPaginationInput(childComplexity), true

	case "XgenObjectMap.XgenResourceActionType":
		if e.complexity.XgenObjectMap.XgenResourceActionType == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceActionType(childComplexity), true

	case "XgenObjectMap.XgenResourceDbConfigInput":
		if e.complexity.XgenObjectMap.XgenResourceDbConfigInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceDbConfigInput(childComplexity), true

	case "XgenObjectMap.XgenResourceFieldDbConfigInput":
		if e.complexity.XgenObjectMap.XgenResourceFieldDbConfigInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceFieldDbConfigInput(childComplexity), true

	case "XgenObjectMap.XgenResourceListActionType":
		if e.complexity.XgenObjectMap.XgenResourceListActionType == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceListActionType(childComplexity), true

	case "XgenPaginationInputXgenDef.field":
		if e.complexity.XgenPaginationInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenPaginationInputXgenDef.Field(childComplexity), true

	case "XgenPaginationInputXgenDef.object":
		if e.complexity.XgenPaginationInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenPaginationInputXgenDef.Object(childComplexity), true

	case "XgenResourceAction.Action":
		if e.complexity.XgenResourceAction.Action == nil {
			break
		}

		return e.complexity.XgenResourceAction.Action(childComplexity), true

	case "XgenResourceAction.Resource":
		if e.complexity.XgenResourceAction.Resource == nil {
			break
		}

		return e.complexity.XgenResourceAction.Resource(childComplexity), true

	case "XgenResourceAction.Route":
		if e.complexity.XgenResourceAction.Route == nil {
			break
		}

		return e.complexity.XgenResourceAction.Route(childComplexity), true

	case "XgenResourceAction.SchemaFieldName":
		if e.complexity.XgenResourceAction.SchemaFieldName == nil {
			break
		}

		return e.complexity.XgenResourceAction.SchemaFieldName(childComplexity), true

	case "XgenResourceActionTypeXgenDef.field":
		if e.complexity.XgenResourceActionTypeXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceActionTypeXgenDef.Field(childComplexity), true

	case "XgenResourceActionTypeXgenDef.object":
		if e.complexity.XgenResourceActionTypeXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceActionTypeXgenDef.Object(childComplexity), true

	case "XgenResourceDbConfigInputXgenDef.field":
		if e.complexity.XgenResourceDbConfigInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceDbConfigInputXgenDef.Field(childComplexity), true

	case "XgenResourceDbConfigInputXgenDef.object":
		if e.complexity.XgenResourceDbConfigInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceDbConfigInputXgenDef.Object(childComplexity), true

	case "XgenResourceDefinition.actions":
		if e.complexity.XgenResourceDefinition.Actions == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.Actions(childComplexity), true

	case "XgenResourceDefinition.objectName":
		if e.complexity.XgenResourceDefinition.ObjectName == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.ObjectName(childComplexity), true

	case "XgenResourceDefinition.properties":
		if e.complexity.XgenResourceDefinition.Properties == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.Properties(childComplexity), true

	case "XgenResourceFieldDbConfigInputXgenDef.field":
		if e.complexity.XgenResourceFieldDbConfigInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceFieldDbConfigInputXgenDef.Field(childComplexity), true

	case "XgenResourceFieldDbConfigInputXgenDef.object":
		if e.complexity.XgenResourceFieldDbConfigInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceFieldDbConfigInputXgenDef.Object(childComplexity), true

	case "XgenResourceListActionTypeXgenDef.field":
		if e.complexity.XgenResourceListActionTypeXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceListActionTypeXgenDef.Field(childComplexity), true

	case "XgenResourceListActionTypeXgenDef.object":
		if e.complexity.XgenResourceListActionTypeXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceListActionTypeXgenDef.Object(childComplexity), true

	case "XgenResourceMap.todo":
		if e.complexity.XgenResourceMap.Todo == nil {
			break
		}

		return e.complexity.XgenResourceMap.Todo(childComplexity), true

	case "XgenResourceMap.user":
		if e.complexity.XgenResourceMap.User == nil {
			break
		}

		return e.complexity.XgenResourceMap.User(childComplexity), true

	case "XgenResourceProperty.Name":
		if e.complexity.XgenResourceProperty.Name == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Name(childComplexity), true

	case "XgenResourceProperty.Primary":
		if e.complexity.XgenResourceProperty.Primary == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Primary(childComplexity), true

	case "XgenResourceProperty.Route":
		if e.complexity.XgenResourceProperty.Route == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Route(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCustomTodo,
		ec.unmarshalInputDeleteTodo,
		ec.unmarshalInputListTodo,
		ec.unmarshalInputNewTodo,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputUpdateTodo,
		ec.unmarshalInputUpdateUser,
		ec.unmarshalInputUserList,
		ec.unmarshalInputXgenCursorPaginationInput,
		ec.unmarshalInputXgenPaginationInput,
		ec.unmarshalInputXgenResourceDbConfigInput,
		ec.unmarshalInputXgenResourceFieldDbConfigInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.main.graphql", Input: `# Custom action for resource
extend enum XgenResourceActionType{
    CUSTOM_MUTATION
}

# Custom directive for resource
directive @XgenCustomConf(Asd: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | INPUT_OBJECT
`, BuiltIn: false},
	{Name: "../schema.todo.graphql", Input: `type Todo
@Resource(Name: "todo", Primary: true, Route: "td", DB: {Table: "Test"})
@XgenCustomConf(Asd: "jiji")
{
    id: ID! @Field(Label: "ID", Description: "ID of the todo", DB: {Column: "ID"})
    text: String! @Field(Label: "Text", Description: "Text of the todo", DB: {Column: "Text"})
    done: Boolean! @Field(Label: "Done", Description: "Done of the todo", DB: {Column: "Done"})
    user: User! @Field(Label: "User", Description: "User of the todo", DB: {Column: "User"})
}

input NewTodo
@Action(Resource: "todo", Action: CREATE_MUTATION, Route: "new", SchemaFieldName: "new_todo")
{
    text: String! @ActionField(Label: "Text", Description: "Text of the todo")
    userId: ID! @ActionField(Label: "User ID", Description: "User ID of the todo")
    code: String! @ActionField(Label: "Code", Description: "Code of the todo")
}

input ListTodo
@ListAction(Resource: "todo", Action: BROWSE_QUERY, Route: "list", Pagination: true)
{
    id: ID! @ActionField(Label: "ID", Description: "ID of the todo")
    text: String! @ActionField(Label: "Text", Description: "Text of the todo")
    done: Boolean! @ActionField(Label: "Done", Description: "Done of the todo")
    userId: ID! @ActionField(Label: "User ID", Description: "User ID of the todo")
    code: String! @ActionField(Label: "Code", Description: "Code of the todo")
}

input CustomTodo
@Action(Resource: "todo", Action: CUSTOM_MUTATION)
{
    text: String!
    userId: ID!
    code: String!
    custom: String!
    custom2: String!
}

input UpdateTodo
@Action(Resource: "todo", Action: UPDATE_MUTATION)
{
    text: String!
    userId: ID!
    code: String!
}

input DeleteTodo
@Action(Resource: "todo", Action: DELETE_MUTATION)
{
    id: ID!
}
`, BuiltIn: false},
	{Name: "../schema.users.graphql", Input: `type User
    @Resource(Name: "user")
{
    id: ID!
    name: String!
}

input NewUser
@Action(Resource: "user", Action: CREATE_MUTATION)
{
    id: ID!
    name: String!
}

input UserList
@ListAction(Resource: "user", Action: BROWSE_QUERY, Pagination: true)
{
    id: ID @ActionField(Label: "ID")
    name: String @ActionField(Label: "Name")
}


input UpdateUser
    @Action(Resource: "user", Action: UPDATE_MUTATION)
{
    id: ID!
    name: String!
}`, BuiltIn: false},
	{Name: "../generated_xgen_directives.graphql", Input: `"""This directive is used to mark the object as a resource"""
directive @Resource(Name: String!, Route: String, Primary: Boolean, DB: XgenResourceDbConfigInput @ExcludeArgumentFromType) on OBJECT
"""This directive is used to mark the object as a resource action"""
directive @Action(Resource: String!, Action: XgenResourceActionType!, Route: String, SchemaFieldName: String) repeatable on INPUT_OBJECT
"""This directive is used to mark the object as a resource list action"""
directive @ListAction(Resource: String!, Action: XgenResourceListActionType!, Route: String, Pagination: Boolean, SchemaFieldName: String) repeatable on INPUT_OBJECT
"""This directive is used to exclude the argument from the type"""
directive @ExcludeArgumentFromType(exclude: Boolean) on ARGUMENT_DEFINITION
"""This directive is used to mark the object as a resource field"""
directive @Field(Label: String, Description: String, DB: XgenResourceFieldDbConfigInput @ExcludeArgumentFromType) on FIELD_DEFINITION
"""This directive is used to mark the object as a resource field"""
directive @ActionField(Label: String, Description: String,
  """Map field to resource field, {resource}.{field}, eg. user.id"""
  MapTo: [String!]
) on INPUT_FIELD_DEFINITION
enum XgenResourceActionType {
  CREATE_MUTATION
  READ_QUERY
  UPDATE_MUTATION
  DELETE_MUTATION
}
enum XgenResourceListActionType {
  BROWSE_QUERY
  BATCH_DELETE_MUTATION
}
input XgenPaginationInput {
  page: Int!
  size: Int!
}
input XgenCursorPaginationInput {
  first: Int!
  after: String
  last: Int!
  before: String
}
input XgenResourceDbConfigInput {
  Table: String
}
input XgenResourceFieldDbConfigInput {
  Column: String
  PrimaryKey: Boolean
  AutoIncrement: Boolean
  Unique: Boolean
  NotNull: Boolean
  Index: Boolean
  UniqueIndex: Boolean
  Size: Int
  Precision: Int
  Type: String
  Scale: Int
  AutoIncrementIncrement: Int
}`, BuiltIn: false},
	{Name: "../../schema", Input: `type XgenIntrospection {
  annotation: XgenAnnotationMap
  object: XgenObjectMap
  resource: XgenResourceMap
}
"""This directive is used to mark the object as a resource"""
type Resource {
  Name: String!
  Route: String
  Primary: Boolean
}
"""This directive is used to mark the object as a resource action"""
type Action {
  Resource: String!
  Action: XgenResourceActionType!
  Route: String
  SchemaFieldName: String
}
"""This directive is used to mark the object as a resource list action"""
type ListAction {
  Resource: String!
  Action: XgenResourceListActionType!
  Route: String
  Pagination: Boolean
  SchemaFieldName: String
}
"""This directive is used to mark the object as a resource field"""
type Field {
  Label: String
  Description: String
}
"""This directive is used to mark the object as a resource field"""
type ActionField {
  Label: String
  Description: String
  """Map field to resource field, {resource}.{field}, eg. user.id"""
  MapTo: [String!]
}
type XgenAnnotationMap {
  Resource: [ResourceAnnotationSingle!]!
  Action: [ActionAnnotationSingle!]!
  ListAction: [ListActionAnnotationSingle!]!
}
type ResourceAnnotationSingle {
  name: String
  value: Resource
}
type ActionAnnotationSingle {
  name: String
  value: Action
}
type ListActionAnnotationSingle {
  name: String
  value: ListAction
}
type XgenFieldDef {
  Field: Field
  ActionField: ActionField
}
type XgenObjectDefinition {
  Action: Action
  ListAction: ListAction
  Resource: Resource
}
type XgenObjectField {
  name: String
  definition: XgenFieldDef
}
type XgenObjectMap {
  XgenPaginationInput: XgenPaginationInputXgenDef
  XgenCursorPaginationInput: XgenCursorPaginationInputXgenDef
  UpdateTodo: UpdateTodoXgenDef
  XgenResourceFieldDbConfigInput: XgenResourceFieldDbConfigInputXgenDef
  DeleteTodo: DeleteTodoXgenDef
  XgenResourceDbConfigInput: XgenResourceDbConfigInputXgenDef
  ListTodo: ListTodoXgenDef
  User: UserXgenDef
  NewTodo: NewTodoXgenDef
  UserList: UserListXgenDef
  XgenResourceListActionType: XgenResourceListActionTypeXgenDef
  UpdateUser: UpdateUserXgenDef
  XgenResourceActionType: XgenResourceActionTypeXgenDef
  Todo: TodoXgenDef
  CustomTodo: CustomTodoXgenDef
  NewUser: NewUserXgenDef
}
type XgenPaginationInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenCursorPaginationInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type UpdateTodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceFieldDbConfigInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type DeleteTodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceDbConfigInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type ListTodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type UserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type NewTodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type UserListXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceListActionTypeXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type UpdateUserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceActionTypeXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type TodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type CustomTodoXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type NewUserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceMap {
  user: XgenResourceDefinition
  todo: XgenResourceDefinition
}
type XgenResourceDefinition {
  objectName: String
  properties: XgenResourceProperty
  actions: [XgenResourceAction]!
}
type XgenResourceProperty {
  Name: String!
  Route: String
  Primary: Boolean
}
type XgenResourceAction {
  Resource: String!
  Action: XgenResourceActionType!
  Route: String
  SchemaFieldName: String
}
extend type Query {
  _xgen_introspection: XgenIntrospection
}
extend type Query {
  user_browse(where: UserList, pagination: XgenPaginationInput): [User]!
  todo_browse(where: ListTodo, pagination: XgenPaginationInput): [Todo]!
}
extend type Mutation {
  todo_delete(input: DeleteTodo): Todo
  todo_custom(input: CustomTodo): Todo
  user_create(input: NewUser): User
  user_update(input: UpdateUser): User
  new_todo(input: NewTodo): Todo
  todo_update(input: UpdateTodo): Todo
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_ActionField_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Label"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Label"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Label"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["MapTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MapTo"))
		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["MapTo"] = arg2
	return args, nil
}

func (ec *executionContext) dir_Action_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Resource"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Resource"] = arg0
	var arg1 XgenResourceActionType
	if tmp, ok := rawArgs["Action"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Action"))
		arg1, err = ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Action"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["SchemaFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("SchemaFieldName"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["SchemaFieldName"] = arg3
	return args, nil
}

func (ec *executionContext) dir_ExcludeArgumentFromType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["exclude"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude"))
		arg0, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["exclude"] = arg0
	return args, nil
}

func (ec *executionContext) dir_Field_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Label"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Label"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Label"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	var arg2 *XgenResourceFieldDbConfigInput
	if tmp, ok := rawArgs["DB"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("DB"))
		arg2, err = ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["DB"] = arg2
	return args, nil
}

func (ec *executionContext) dir_ListAction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Resource"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Resource"] = arg0
	var arg1 XgenResourceListActionType
	if tmp, ok := rawArgs["Action"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Action"))
		arg1, err = ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Action"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["Pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Pagination"))
		arg3, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Pagination"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["SchemaFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("SchemaFieldName"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["SchemaFieldName"] = arg4
	return args, nil
}

func (ec *executionContext) dir_Resource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["Primary"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Primary"))
		arg2, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Primary"] = arg2
	var arg3 *XgenResourceDbConfigInput
	if tmp, ok := rawArgs["DB"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("DB"))
		arg3, err = ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["DB"] = arg3
	return args, nil
}

func (ec *executionContext) dir_XgenCustomConf_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Asd"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Asd"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Asd"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_new_todo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *NewTodo
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalONewTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewTodo(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_todo_custom_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CustomTodo
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCustomTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐCustomTodo(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_todo_delete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteTodo
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐDeleteTodo(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_todo_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateTodo
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateTodo(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_user_create_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *NewUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalONewUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_user_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UpdateUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUpdateUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_todo_browse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListTodo
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOListTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListTodo(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *XgenPaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOXgenPaginationInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_user_browse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *UserList
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOUserList2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserList(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *XgenPaginationInput
	if tmp, ok := rawArgs["pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
		arg1, err = ec.unmarshalOXgenPaginationInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenPaginationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagination"] = arg1
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Action_Resource(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_Action(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceActionType)
	fc.Result = res
	return ec.marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_Route(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Action)
	fc.Result = res
	return ec.marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_Action_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_Action_Action(ctx, field)
			case "Route":
				return ec.fieldContext_Action_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_Action_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Action", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionField_Label(ctx context.Context, field graphql.CollectedField, obj *ActionField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionField_Label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionField_Label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionField_Description(ctx context.Context, field graphql.CollectedField, obj *ActionField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionField_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionField_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionField_MapTo(ctx context.Context, field graphql.CollectedField, obj *ActionField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionField_MapTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MapTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionField_MapTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomTodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *CustomTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomTodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomTodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CustomTodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *CustomTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CustomTodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CustomTodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CustomTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteTodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *DeleteTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteTodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteTodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteTodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *DeleteTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteTodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteTodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Field_Label(ctx context.Context, field graphql.CollectedField, obj *Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Field_Label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Field_Label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Field_Description(ctx context.Context, field graphql.CollectedField, obj *Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Field_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Field_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Resource(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Action(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceListActionType)
	fc.Result = res
	return ec.marshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceListActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Route(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Pagination(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ListActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListActionAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ListActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListActionAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListAction)
	fc.Result = res
	return ec.marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_ListAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_ListAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_ListAction_Route(ctx, field)
			case "Pagination":
				return ec.fieldContext_ListAction_Pagination(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *ListTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListTodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *ListTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListTodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListTodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_todo_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_todo_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TodoDelete(rctx, fc.Args["input"].(*DeleteTodo))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "todo")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "td")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "Test"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, nil, directive1, asd)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Todo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.Todo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Todo)
	fc.Result = res
	return ec.marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_todo_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_todo_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_todo_custom(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_todo_custom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TodoCustom(rctx, fc.Args["input"].(*CustomTodo))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "todo")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "td")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "Test"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, nil, directive1, asd)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Todo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.Todo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Todo)
	fc.Result = res
	return ec.marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_todo_custom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_todo_custom_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_user_create(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_user_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserCreate(rctx, fc.Args["input"].(*NewUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_user_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_user_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_user_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_user_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserUpdate(rctx, fc.Args["input"].(*UpdateUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_user_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_user_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_new_todo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_new_todo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().NewTodo(rctx, fc.Args["input"].(*NewTodo))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "todo")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "td")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "Test"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, nil, directive1, asd)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Todo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.Todo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Todo)
	fc.Result = res
	return ec.marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_new_todo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_new_todo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_todo_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_todo_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TodoUpdate(rctx, fc.Args["input"].(*UpdateTodo))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "todo")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "td")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "Test"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, nil, directive1, asd)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Todo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.Todo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Todo)
	fc.Result = res
	return ec.marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_todo_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_todo_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NewTodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *NewTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewTodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewTodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewTodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *NewTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewTodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewTodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewUserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *NewUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewUserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewUserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewUserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *NewUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewUserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewUserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query__xgen_introspection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__xgen_introspection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().XgenIntrospection(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenIntrospection)
	fc.Result = res
	return ec.marshalOXgenIntrospection2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenIntrospection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__xgen_introspection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "annotation":
				return ec.fieldContext_XgenIntrospection_annotation(ctx, field)
			case "object":
				return ec.fieldContext_XgenIntrospection_object(ctx, field)
			case "resource":
				return ec.fieldContext_XgenIntrospection_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenIntrospection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user_browse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user_browse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UserBrowse(rctx, fc.Args["where"].(*UserList), fc.Args["pagination"].(*XgenPaginationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, nil, nil, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user_browse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_browse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_todo_browse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_todo_browse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().TodoBrowse(rctx, fc.Args["where"].(*ListTodo), fc.Args["pagination"].(*XgenPaginationInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "todo")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "td")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "Test"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, nil, directive1, asd)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Todo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.Todo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Todo)
	fc.Result = res
	return ec.marshalNTodo2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_todo_browse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "text":
				return ec.fieldContext_Todo_text(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_todo_browse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Name(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Route(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Primary(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Primary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Primary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ResourceAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ResourceAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Resource)
	fc.Result = res
	return ec.marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_Resource_Name(ctx, field)
			case "Route":
				return ec.fieldContext_Resource_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_Resource_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_id(ctx context.Context, field graphql.CollectedField, obj *Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, obj, directive0, asd)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "ID of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "ID"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive1, label, description, db)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_text(ctx context.Context, field graphql.CollectedField, obj *Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Text, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, obj, directive0, asd)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Text")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Text of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "Text"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive1, label, description, db)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_done(ctx context.Context, field graphql.CollectedField, obj *Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Done, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, obj, directive0, asd)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Done")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Done of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "Done"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive1, label, description, db)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_done(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Todo_user(ctx context.Context, field graphql.CollectedField, obj *Todo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Todo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.User, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, obj, directive0, name, nil, nil, nil)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			asd, err := ec.unmarshalOString2ᚖstring(ctx, "jiji")
			if err != nil {
				return nil, err
			}
			if ec.directives.XgenCustomConf == nil {
				return nil, errors.New("directive XgenCustomConf is not implemented")
			}
			return ec.directives.XgenCustomConf(ctx, obj, directive1, asd)
		}
		directive3 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "User")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "User of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "User"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive2, label, description, db)
		}

		tmp, err := directive3(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/cmd/internal/integration/myproject/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *TodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *TodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTodoXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *UpdateTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTodoXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTodoXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTodoXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *UpdateTodoXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTodoXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTodoXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTodoXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *UpdateUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *UpdateUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserListXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *UserListXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserListXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserListXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserListXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserListXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *UserListXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserListXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserListXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserListXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *UserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *UserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ResourceAnnotationSingle)
	fc.Result = res
	return ec.marshalNResourceAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResourceAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ResourceAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ResourceAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_Action(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ActionAnnotationSingle)
	fc.Result = res
	return ec.marshalNActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ActionAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ActionAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActionAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_ListAction(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_ListAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ListActionAnnotationSingle)
	fc.Result = res
	return ec.marshalNListActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListActionAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_ListAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ListActionAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ListActionAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListActionAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenCursorPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenCursorPaginationInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenCursorPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenCursorPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenCursorPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenCursorPaginationInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenCursorPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenCursorPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenFieldDef_Field(ctx context.Context, field graphql.CollectedField, obj *XgenFieldDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenFieldDef_Field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Field)
	fc.Result = res
	return ec.marshalOField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenFieldDef_Field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenFieldDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Label":
				return ec.fieldContext_Field_Label(ctx, field)
			case "Description":
				return ec.fieldContext_Field_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Field", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenFieldDef_ActionField(ctx context.Context, field graphql.CollectedField, obj *XgenFieldDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenFieldDef_ActionField(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActionField, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ActionField)
	fc.Result = res
	return ec.marshalOActionField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenFieldDef_ActionField(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenFieldDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Label":
				return ec.fieldContext_ActionField_Label(ctx, field)
			case "Description":
				return ec.fieldContext_ActionField_Description(ctx, field)
			case "MapTo":
				return ec.fieldContext_ActionField_MapTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActionField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_annotation(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenAnnotationMap)
	fc.Result = res
	return ec.marshalOXgenAnnotationMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenAnnotationMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_annotation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenAnnotationMap_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_XgenAnnotationMap_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenAnnotationMap_ListAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenAnnotationMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_object(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectMap)
	fc.Result = res
	return ec.marshalOXgenObjectMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "XgenPaginationInput":
				return ec.fieldContext_XgenObjectMap_XgenPaginationInput(ctx, field)
			case "XgenCursorPaginationInput":
				return ec.fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx, field)
			case "UpdateTodo":
				return ec.fieldContext_XgenObjectMap_UpdateTodo(ctx, field)
			case "XgenResourceFieldDbConfigInput":
				return ec.fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field)
			case "DeleteTodo":
				return ec.fieldContext_XgenObjectMap_DeleteTodo(ctx, field)
			case "XgenResourceDbConfigInput":
				return ec.fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx, field)
			case "ListTodo":
				return ec.fieldContext_XgenObjectMap_ListTodo(ctx, field)
			case "User":
				return ec.fieldContext_XgenObjectMap_User(ctx, field)
			case "NewTodo":
				return ec.fieldContext_XgenObjectMap_NewTodo(ctx, field)
			case "UserList":
				return ec.fieldContext_XgenObjectMap_UserList(ctx, field)
			case "XgenResourceListActionType":
				return ec.fieldContext_XgenObjectMap_XgenResourceListActionType(ctx, field)
			case "UpdateUser":
				return ec.fieldContext_XgenObjectMap_UpdateUser(ctx, field)
			case "XgenResourceActionType":
				return ec.fieldContext_XgenObjectMap_XgenResourceActionType(ctx, field)
			case "Todo":
				return ec.fieldContext_XgenObjectMap_Todo(ctx, field)
			case "CustomTodo":
				return ec.fieldContext_XgenObjectMap_CustomTodo(ctx, field)
			case "NewUser":
				return ec.fieldContext_XgenObjectMap_NewUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_resource(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceMap)
	fc.Result = res
	return ec.marshalOXgenResourceMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_XgenResourceMap_user(ctx, field)
			case "todo":
				return ec.fieldContext_XgenResourceMap_todo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_Action(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Action)
	fc.Result = res
	return ec.marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_Action_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_Action_Action(ctx, field)
			case "Route":
				return ec.fieldContext_Action_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_Action_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Action", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_ListAction(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListAction)
	fc.Result = res
	return ec.marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_ListAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_ListAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_ListAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_ListAction_Route(ctx, field)
			case "Pagination":
				return ec.fieldContext_ListAction_Pagination(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Resource)
	fc.Result = res
	return ec.marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_Resource_Name(ctx, field)
			case "Route":
				return ec.fieldContext_Resource_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_Resource_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectField_name(ctx context.Context, field graphql.CollectedField, obj *XgenObjectField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectField_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectField_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectField_definition(ctx context.Context, field graphql.CollectedField, obj *XgenObjectField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectField_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Definition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenFieldDef)
	fc.Result = res
	return ec.marshalOXgenFieldDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenFieldDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectField_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Field":
				return ec.fieldContext_XgenFieldDef_Field(ctx, field)
			case "ActionField":
				return ec.fieldContext_XgenFieldDef_ActionField(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenFieldDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenPaginationInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenPaginationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenPaginationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenPaginationInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenPaginationInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenPaginationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenPaginationInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenPaginationInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenPaginationInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenCursorPaginationInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenCursorPaginationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenCursorPaginationInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenCursorPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenCursorPaginationInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenCursorPaginationInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenCursorPaginationInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenCursorPaginationInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_UpdateTodo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_UpdateTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTodo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateTodoXgenDef)
	fc.Result = res
	return ec.marshalOUpdateTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_UpdateTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_UpdateTodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_UpdateTodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceFieldDbConfigInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceFieldDbConfigInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceFieldDbConfigInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceFieldDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceFieldDbConfigInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_DeleteTodo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_DeleteTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteTodo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteTodoXgenDef)
	fc.Result = res
	return ec.marshalODeleteTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐDeleteTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_DeleteTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_DeleteTodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_DeleteTodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteTodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceDbConfigInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceDbConfigInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDbConfigInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDbConfigInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_ListTodo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_ListTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListTodo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListTodoXgenDef)
	fc.Result = res
	return ec.marshalOListTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_ListTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_ListTodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_ListTodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListTodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_User(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_User(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserXgenDef)
	fc.Result = res
	return ec.marshalOUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_User(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_UserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_UserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_NewTodo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_NewTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewTodo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NewTodoXgenDef)
	fc.Result = res
	return ec.marshalONewTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_NewTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_NewTodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_NewTodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewTodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_UserList(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_UserList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserList, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserListXgenDef)
	fc.Result = res
	return ec.marshalOUserListXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserListXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_UserList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_UserListXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_UserListXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserListXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceListActionType(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceListActionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceListActionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceListActionTypeXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceListActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionTypeXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceListActionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceListActionTypeXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceListActionTypeXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceListActionTypeXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_UpdateUser(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_UpdateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateUserXgenDef)
	fc.Result = res
	return ec.marshalOUpdateUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_UpdateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_UpdateUserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_UpdateUserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateUserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceActionType(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceActionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceActionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceActionTypeXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionTypeXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceActionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceActionTypeXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceActionTypeXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceActionTypeXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_Todo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_Todo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Todo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TodoXgenDef)
	fc.Result = res
	return ec.marshalOTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_Todo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_TodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_TodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_CustomTodo(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_CustomTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CustomTodo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CustomTodoXgenDef)
	fc.Result = res
	return ec.marshalOCustomTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐCustomTodoXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_CustomTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_CustomTodoXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_CustomTodoXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CustomTodoXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_NewUser(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_NewUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NewUserXgenDef)
	fc.Result = res
	return ec.marshalONewUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_NewUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_NewUserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_NewUserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewUserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenPaginationInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenPaginationInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Action(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceActionType)
	fc.Result = res
	return ec.marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Route(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceActionTypeXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceActionTypeXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_objectName(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObjectName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_objectName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_properties(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceProperty)
	fc.Result = res
	return ec.marshalOXgenResourceProperty2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_XgenResourceProperty_Name(ctx, field)
			case "Route":
				return ec.fieldContext_XgenResourceProperty_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_XgenResourceProperty_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_actions(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenResourceAction)
	fc.Result = res
	return ec.marshalNXgenResourceAction2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_actions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenResourceAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_XgenResourceAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_XgenResourceAction_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_XgenResourceAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceFieldDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceFieldDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceFieldDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceFieldDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceListActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceListActionTypeXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceListActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceListActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceListActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceListActionTypeXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceListActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceListActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceMap_user(ctx context.Context, field graphql.CollectedField, obj *XgenResourceMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceMap_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDefinition)
	fc.Result = res
	return ec.marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceMap_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "objectName":
				return ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
			case "properties":
				return ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
			case "actions":
				return ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceMap_todo(ctx context.Context, field graphql.CollectedField, obj *XgenResourceMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceMap_todo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Todo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDefinition)
	fc.Result = res
	return ec.marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceMap_todo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "objectName":
				return ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
			case "properties":
				return ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
			case "actions":
				return ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Name(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Route(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Primary(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Primary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Primary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCustomTodo(ctx context.Context, obj interface{}) (CustomTodo, error) {
	var it CustomTodo
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "userId", "code", "custom", "custom2"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CUSTOM_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Text = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CUSTOM_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.UserID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CUSTOM_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Code = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "custom":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("custom"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CUSTOM_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Custom = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "custom2":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("custom2"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CUSTOM_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Custom2 = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteTodo(ctx context.Context, obj interface{}) (DeleteTodo, error) {
	var it DeleteTodo
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "DELETE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListTodo(ctx context.Context, obj interface{}) (ListTodo, error) {
	var it ListTodo
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "text", "done", "userId", "code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "ID of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Text")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Text of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Text = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "done":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("done"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNBoolean2bool(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Done")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Done of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(bool); ok {
				it.Done = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "User ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "User ID of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.UserID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Code")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Code of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Code = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewTodo(ctx context.Context, obj interface{}) (NewTodo, error) {
	var it NewTodo
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "userId", "code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Text")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Text of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Text = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "User ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "User ID of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.UserID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Code")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Code of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Code = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUser(ctx context.Context, obj interface{}) (NewUser, error) {
	var it NewUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTodo(ctx context.Context, obj interface{}) (UpdateTodo, error) {
	var it UpdateTodo
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "userId", "code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Text = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.UserID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "todo")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Code = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUser(ctx context.Context, obj interface{}) (UpdateUser, error) {
	var it UpdateUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2int(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int); ok {
				it.ID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, nil, nil)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserList(ctx context.Context, obj interface{}) (UserList, error) {
	var it UserList
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, nil, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, nil, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.ID = data
			} else if tmp == nil {
				it.ID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				pagination, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, nil, pagination, nil)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Name")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, nil, nil)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenCursorPaginationInput(ctx context.Context, obj interface{}) (XgenCursorPaginationInput, error) {
	var it XgenCursorPaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "after", "last", "before"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenPaginationInput(ctx context.Context, obj interface{}) (XgenPaginationInput, error) {
	var it XgenPaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "size"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenResourceDbConfigInput(ctx context.Context, obj interface{}) (XgenResourceDbConfigInput, error) {
	var it XgenResourceDbConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Table"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Table":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Table"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Table = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenResourceFieldDbConfigInput(ctx context.Context, obj interface{}) (XgenResourceFieldDbConfigInput, error) {
	var it XgenResourceFieldDbConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Column", "PrimaryKey", "AutoIncrement", "Unique", "NotNull", "Index", "UniqueIndex", "Size", "Precision", "Type", "Scale", "AutoIncrementIncrement"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Column":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Column"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Column = data
		case "PrimaryKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("PrimaryKey"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryKey = data
		case "AutoIncrement":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AutoIncrement"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoIncrement = data
		case "Unique":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Unique"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unique = data
		case "NotNull":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NotNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotNull = data
		case "Index":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Index"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Index = data
		case "UniqueIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("UniqueIndex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UniqueIndex = data
		case "Size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Size"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "Precision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Precision"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Precision = data
		case "Type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "Scale":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Scale"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scale = data
		case "AutoIncrementIncrement":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AutoIncrementIncrement"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoIncrementIncrement = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionImplementors = []string{"Action"}

func (ec *executionContext) _Action(ctx context.Context, sel ast.SelectionSet, obj *Action) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Action")
		case "Resource":
			out.Values[i] = ec._Action_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._Action_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._Action_Route(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._Action_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var actionAnnotationSingleImplementors = []string{"ActionAnnotationSingle"}

func (ec *executionContext) _ActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ActionAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionAnnotationSingle")
		case "name":
			out.Values[i] = ec._ActionAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ActionAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var actionFieldImplementors = []string{"ActionField"}

func (ec *executionContext) _ActionField(ctx context.Context, sel ast.SelectionSet, obj *ActionField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionField")
		case "Label":
			out.Values[i] = ec._ActionField_Label(ctx, field, obj)
		case "Description":
			out.Values[i] = ec._ActionField_Description(ctx, field, obj)
		case "MapTo":
			out.Values[i] = ec._ActionField_MapTo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var customTodoXgenDefImplementors = []string{"CustomTodoXgenDef"}

func (ec *executionContext) _CustomTodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *CustomTodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, customTodoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CustomTodoXgenDef")
		case "object":
			out.Values[i] = ec._CustomTodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._CustomTodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteTodoXgenDefImplementors = []string{"DeleteTodoXgenDef"}

func (ec *executionContext) _DeleteTodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *DeleteTodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteTodoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteTodoXgenDef")
		case "object":
			out.Values[i] = ec._DeleteTodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._DeleteTodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fieldImplementors = []string{"Field"}

func (ec *executionContext) _Field(ctx context.Context, sel ast.SelectionSet, obj *Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Field")
		case "Label":
			out.Values[i] = ec._Field_Label(ctx, field, obj)
		case "Description":
			out.Values[i] = ec._Field_Description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listActionImplementors = []string{"ListAction"}

func (ec *executionContext) _ListAction(ctx context.Context, sel ast.SelectionSet, obj *ListAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListAction")
		case "Resource":
			out.Values[i] = ec._ListAction_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._ListAction_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._ListAction_Route(ctx, field, obj)
		case "Pagination":
			out.Values[i] = ec._ListAction_Pagination(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._ListAction_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listActionAnnotationSingleImplementors = []string{"ListActionAnnotationSingle"}

func (ec *executionContext) _ListActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ListActionAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listActionAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListActionAnnotationSingle")
		case "name":
			out.Values[i] = ec._ListActionAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ListActionAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listTodoXgenDefImplementors = []string{"ListTodoXgenDef"}

func (ec *executionContext) _ListTodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *ListTodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listTodoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListTodoXgenDef")
		case "object":
			out.Values[i] = ec._ListTodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._ListTodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "todo_delete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_todo_delete(ctx, field)
			})
		case "todo_custom":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_todo_custom(ctx, field)
			})
		case "user_create":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_user_create(ctx, field)
			})
		case "user_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_user_update(ctx, field)
			})
		case "new_todo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_new_todo(ctx, field)
			})
		case "todo_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_todo_update(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newTodoXgenDefImplementors = []string{"NewTodoXgenDef"}

func (ec *executionContext) _NewTodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *NewTodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newTodoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewTodoXgenDef")
		case "object":
			out.Values[i] = ec._NewTodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._NewTodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newUserXgenDefImplementors = []string{"NewUserXgenDef"}

func (ec *executionContext) _NewUserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *NewUserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newUserXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewUserXgenDef")
		case "object":
			out.Values[i] = ec._NewUserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._NewUserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "_xgen_introspection":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__xgen_introspection(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user_browse":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user_browse(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "todo_browse":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_todo_browse(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceImplementors = []string{"Resource"}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj *Resource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resource")
		case "Name":
			out.Values[i] = ec._Resource_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._Resource_Route(ctx, field, obj)
		case "Primary":
			out.Values[i] = ec._Resource_Primary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceAnnotationSingleImplementors = []string{"ResourceAnnotationSingle"}

func (ec *executionContext) _ResourceAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ResourceAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceAnnotationSingle")
		case "name":
			out.Values[i] = ec._ResourceAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ResourceAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var todoImplementors = []string{"Todo"}

func (ec *executionContext) _Todo(ctx context.Context, sel ast.SelectionSet, obj *Todo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, todoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Todo")
		case "id":
			out.Values[i] = ec._Todo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._Todo_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "done":
			out.Values[i] = ec._Todo_done(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Todo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var todoXgenDefImplementors = []string{"TodoXgenDef"}

func (ec *executionContext) _TodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *TodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, todoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TodoXgenDef")
		case "object":
			out.Values[i] = ec._TodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._TodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateTodoXgenDefImplementors = []string{"UpdateTodoXgenDef"}

func (ec *executionContext) _UpdateTodoXgenDef(ctx context.Context, sel ast.SelectionSet, obj *UpdateTodoXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTodoXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTodoXgenDef")
		case "object":
			out.Values[i] = ec._UpdateTodoXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._UpdateTodoXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateUserXgenDefImplementors = []string{"UpdateUserXgenDef"}

func (ec *executionContext) _UpdateUserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *UpdateUserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateUserXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateUserXgenDef")
		case "object":
			out.Values[i] = ec._UpdateUserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._UpdateUserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userListXgenDefImplementors = []string{"UserListXgenDef"}

func (ec *executionContext) _UserListXgenDef(ctx context.Context, sel ast.SelectionSet, obj *UserListXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userListXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserListXgenDef")
		case "object":
			out.Values[i] = ec._UserListXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._UserListXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userXgenDefImplementors = []string{"UserXgenDef"}

func (ec *executionContext) _UserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *UserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserXgenDef")
		case "object":
			out.Values[i] = ec._UserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._UserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenAnnotationMapImplementors = []string{"XgenAnnotationMap"}

func (ec *executionContext) _XgenAnnotationMap(ctx context.Context, sel ast.SelectionSet, obj *XgenAnnotationMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenAnnotationMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenAnnotationMap")
		case "Resource":
			out.Values[i] = ec._XgenAnnotationMap_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._XgenAnnotationMap_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ListAction":
			out.Values[i] = ec._XgenAnnotationMap_ListAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenCursorPaginationInputXgenDefImplementors = []string{"XgenCursorPaginationInputXgenDef"}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenCursorPaginationInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenCursorPaginationInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenCursorPaginationInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenCursorPaginationInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenCursorPaginationInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenFieldDefImplementors = []string{"XgenFieldDef"}

func (ec *executionContext) _XgenFieldDef(ctx context.Context, sel ast.SelectionSet, obj *XgenFieldDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenFieldDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenFieldDef")
		case "Field":
			out.Values[i] = ec._XgenFieldDef_Field(ctx, field, obj)
		case "ActionField":
			out.Values[i] = ec._XgenFieldDef_ActionField(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenIntrospectionImplementors = []string{"XgenIntrospection"}

func (ec *executionContext) _XgenIntrospection(ctx context.Context, sel ast.SelectionSet, obj *XgenIntrospection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenIntrospectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenIntrospection")
		case "annotation":
			out.Values[i] = ec._XgenIntrospection_annotation(ctx, field, obj)
		case "object":
			out.Values[i] = ec._XgenIntrospection_object(ctx, field, obj)
		case "resource":
			out.Values[i] = ec._XgenIntrospection_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectDefinitionImplementors = []string{"XgenObjectDefinition"}

func (ec *executionContext) _XgenObjectDefinition(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectDefinition")
		case "Action":
			out.Values[i] = ec._XgenObjectDefinition_Action(ctx, field, obj)
		case "ListAction":
			out.Values[i] = ec._XgenObjectDefinition_ListAction(ctx, field, obj)
		case "Resource":
			out.Values[i] = ec._XgenObjectDefinition_Resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectFieldImplementors = []string{"XgenObjectField"}

func (ec *executionContext) _XgenObjectField(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectField")
		case "name":
			out.Values[i] = ec._XgenObjectField_name(ctx, field, obj)
		case "definition":
			out.Values[i] = ec._XgenObjectField_definition(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectMapImplementors = []string{"XgenObjectMap"}

func (ec *executionContext) _XgenObjectMap(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectMap")
		case "XgenPaginationInput":
			out.Values[i] = ec._XgenObjectMap_XgenPaginationInput(ctx, field, obj)
		case "XgenCursorPaginationInput":
			out.Values[i] = ec._XgenObjectMap_XgenCursorPaginationInput(ctx, field, obj)
		case "UpdateTodo":
			out.Values[i] = ec._XgenObjectMap_UpdateTodo(ctx, field, obj)
		case "XgenResourceFieldDbConfigInput":
			out.Values[i] = ec._XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field, obj)
		case "DeleteTodo":
			out.Values[i] = ec._XgenObjectMap_DeleteTodo(ctx, field, obj)
		case "XgenResourceDbConfigInput":
			out.Values[i] = ec._XgenObjectMap_XgenResourceDbConfigInput(ctx, field, obj)
		case "ListTodo":
			out.Values[i] = ec._XgenObjectMap_ListTodo(ctx, field, obj)
		case "User":
			out.Values[i] = ec._XgenObjectMap_User(ctx, field, obj)
		case "NewTodo":
			out.Values[i] = ec._XgenObjectMap_NewTodo(ctx, field, obj)
		case "UserList":
			out.Values[i] = ec._XgenObjectMap_UserList(ctx, field, obj)
		case "XgenResourceListActionType":
			out.Values[i] = ec._XgenObjectMap_XgenResourceListActionType(ctx, field, obj)
		case "UpdateUser":
			out.Values[i] = ec._XgenObjectMap_UpdateUser(ctx, field, obj)
		case "XgenResourceActionType":
			out.Values[i] = ec._XgenObjectMap_XgenResourceActionType(ctx, field, obj)
		case "Todo":
			out.Values[i] = ec._XgenObjectMap_Todo(ctx, field, obj)
		case "CustomTodo":
			out.Values[i] = ec._XgenObjectMap_CustomTodo(ctx, field, obj)
		case "NewUser":
			out.Values[i] = ec._XgenObjectMap_NewUser(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenPaginationInputXgenDefImplementors = []string{"XgenPaginationInputXgenDef"}

func (ec *executionContext) _XgenPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenPaginationInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenPaginationInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenPaginationInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenPaginationInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenPaginationInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceActionImplementors = []string{"XgenResourceAction"}

func (ec *executionContext) _XgenResourceAction(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceAction")
		case "Resource":
			out.Values[i] = ec._XgenResourceAction_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._XgenResourceAction_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._XgenResourceAction_Route(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._XgenResourceAction_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceActionTypeXgenDefImplementors = []string{"XgenResourceActionTypeXgenDef"}

func (ec *executionContext) _XgenResourceActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceActionTypeXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceActionTypeXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceActionTypeXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceActionTypeXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceActionTypeXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceDbConfigInputXgenDefImplementors = []string{"XgenResourceDbConfigInputXgenDef"}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceDbConfigInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceDbConfigInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceDbConfigInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceDbConfigInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceDbConfigInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceDefinitionImplementors = []string{"XgenResourceDefinition"}

func (ec *executionContext) _XgenResourceDefinition(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceDefinition")
		case "objectName":
			out.Values[i] = ec._XgenResourceDefinition_objectName(ctx, field, obj)
		case "properties":
			out.Values[i] = ec._XgenResourceDefinition_properties(ctx, field, obj)
		case "actions":
			out.Values[i] = ec._XgenResourceDefinition_actions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceFieldDbConfigInputXgenDefImplementors = []string{"XgenResourceFieldDbConfigInputXgenDef"}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceFieldDbConfigInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceFieldDbConfigInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceFieldDbConfigInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceFieldDbConfigInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceFieldDbConfigInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceListActionTypeXgenDefImplementors = []string{"XgenResourceListActionTypeXgenDef"}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceListActionTypeXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceListActionTypeXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceListActionTypeXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceListActionTypeXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceListActionTypeXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceMapImplementors = []string{"XgenResourceMap"}

func (ec *executionContext) _XgenResourceMap(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceMap")
		case "user":
			out.Values[i] = ec._XgenResourceMap_user(ctx, field, obj)
		case "todo":
			out.Values[i] = ec._XgenResourceMap_todo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourcePropertyImplementors = []string{"XgenResourceProperty"}

func (ec *executionContext) _XgenResourceProperty(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourcePropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceProperty")
		case "Name":
			out.Values[i] = ec._XgenResourceProperty_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._XgenResourceProperty_Route(ctx, field, obj)
		case "Primary":
			out.Values[i] = ec._XgenResourceProperty_Primary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ActionAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ActionAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ActionAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNListActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListActionAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ListActionAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNListActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListActionAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNListActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ListActionAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListActionAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResourceAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ResourceAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResourceAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResourceAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ResourceAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTodo2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx context.Context, sel ast.SelectionSet, v []*Todo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []*XgenObjectField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNXgenObjectField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNXgenObjectField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectField(ctx context.Context, sel ast.SelectionSet, v *XgenObjectField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._XgenObjectField(ctx, sel, v)
}

func (ec *executionContext) marshalNXgenResourceAction2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceAction(ctx context.Context, sel ast.SelectionSet, v []*XgenResourceAction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOXgenResourceAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceAction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx context.Context, v interface{}) (XgenResourceActionType, error) {
	var res XgenResourceActionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionType(ctx context.Context, sel ast.SelectionSet, v XgenResourceActionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx context.Context, v interface{}) (XgenResourceListActionType, error) {
	var res XgenResourceListActionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionType(ctx context.Context, sel ast.SelectionSet, v XgenResourceListActionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐAction(ctx context.Context, sel ast.SelectionSet, v *Action) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Action(ctx, sel, v)
}

func (ec *executionContext) marshalOActionField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐActionField(ctx context.Context, sel ast.SelectionSet, v *ActionField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ActionField(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCustomTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐCustomTodo(ctx context.Context, v interface{}) (*CustomTodo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCustomTodo(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCustomTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐCustomTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *CustomTodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CustomTodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalODeleteTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐDeleteTodo(ctx context.Context, v interface{}) (*DeleteTodo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteTodo(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeleteTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐDeleteTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *DeleteTodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteTodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐField(ctx context.Context, sel ast.SelectionSet, v *Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Field(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListAction(ctx context.Context, sel ast.SelectionSet, v *ListAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListAction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListTodo(ctx context.Context, v interface{}) (*ListTodo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListTodo(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOListTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐListTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *ListTodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListTodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalONewTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewTodo(ctx context.Context, v interface{}) (*NewTodo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNewTodo(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONewTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *NewTodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NewTodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalONewUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewUser(ctx context.Context, v interface{}) (*NewUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNewUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONewUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐNewUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *NewUserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NewUserXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐResource(ctx context.Context, sel ast.SelectionSet, v *Resource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodo(ctx context.Context, sel ast.SelectionSet, v *Todo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Todo(ctx, sel, v)
}

func (ec *executionContext) marshalOTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *TodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUpdateTodo2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateTodo(ctx context.Context, v interface{}) (*UpdateTodo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateTodo(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdateTodoXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateTodoXgenDef(ctx context.Context, sel ast.SelectionSet, v *UpdateTodoXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateTodoXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUpdateUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateUser(ctx context.Context, v interface{}) (*UpdateUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdateUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUpdateUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *UpdateUserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateUserXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserList2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserList(ctx context.Context, v interface{}) (*UserList, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserList(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserListXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserListXgenDef(ctx context.Context, sel ast.SelectionSet, v *UserListXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserListXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *UserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenAnnotationMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenAnnotationMap(ctx context.Context, sel ast.SelectionSet, v *XgenAnnotationMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenAnnotationMap(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenCursorPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenCursorPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenCursorPaginationInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenCursorPaginationInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenFieldDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenFieldDef(ctx context.Context, sel ast.SelectionSet, v *XgenFieldDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenFieldDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenIntrospection2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenIntrospection(ctx context.Context, sel ast.SelectionSet, v *XgenIntrospection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenIntrospection(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectDefinition(ctx context.Context, sel ast.SelectionSet, v *XgenObjectDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenObjectDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenObjectMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenObjectMap(ctx context.Context, sel ast.SelectionSet, v *XgenObjectMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenObjectMap(ctx, sel, v)
}

func (ec *executionContext) unmarshalOXgenPaginationInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenPaginationInput(ctx context.Context, v interface{}) (*XgenPaginationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputXgenPaginationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOXgenPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenPaginationInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenPaginationInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceAction(ctx context.Context, sel ast.SelectionSet, v *XgenResourceAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceAction(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceActionTypeXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceActionTypeXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInput(ctx context.Context, v interface{}) (*XgenResourceDbConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputXgenResourceDbConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOXgenResourceDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceDbConfigInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceDbConfigInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceDefinition(ctx context.Context, sel ast.SelectionSet, v *XgenResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx context.Context, v interface{}) (*XgenResourceFieldDbConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputXgenResourceFieldDbConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOXgenResourceFieldDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceFieldDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceFieldDbConfigInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceFieldDbConfigInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceListActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceListActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceListActionTypeXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceListActionTypeXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceMap(ctx context.Context, sel ast.SelectionSet, v *XgenResourceMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceMap(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceProperty2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋcmdᚋinternalᚋintegrationᚋmyprojectᚋgeneratedᚐXgenResourceProperty(ctx context.Context, sel ast.SelectionSet, v *XgenResourceProperty) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceProperty(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
