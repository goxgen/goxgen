// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Action                  func(ctx context.Context, obj interface{}, next graphql.Resolver, resource string, action XgenResourceActionType, route *string, schemaFieldName *string) (res interface{}, err error)
	ActionField             func(ctx context.Context, obj interface{}, next graphql.Resolver, label *string, description *string) (res interface{}, err error)
	ExcludeArgumentFromType func(ctx context.Context, obj interface{}, next graphql.Resolver, exclude *bool) (res interface{}, err error)
	Field                   func(ctx context.Context, obj interface{}, next graphql.Resolver, label *string, description *string, db *XgenResourceFieldDbConfigInput) (res interface{}, err error)
	ListAction              func(ctx context.Context, obj interface{}, next graphql.Resolver, resource string, action XgenResourceListActionType, route *string, pagination *bool, schemaFieldName *string) (res interface{}, err error)
	Resource                func(ctx context.Context, obj interface{}, next graphql.Resolver, name string, route *string, primary *bool, db *XgenResourceDbConfigInput) (res interface{}, err error)
}

type ComplexityRoot struct {
	Action struct {
		Action          func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	ActionAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ActionField struct {
		Description func(childComplexity int) int
		Label       func(childComplexity int) int
	}

	Car struct {
		Done func(childComplexity int) int
		ID   func(childComplexity int) int
		Make func(childComplexity int) int
		User func(childComplexity int) int
	}

	CarInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	CarXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	DeleteUsersXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Field struct {
		Description func(childComplexity int) int
		Label       func(childComplexity int) int
	}

	ListAction struct {
		Action          func(childComplexity int) int
		Pagination      func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	ListActionAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ListCarsXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	ListUserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Mutation struct {
		DeleteUsers func(childComplexity int, input *DeleteUsers) int
		NewCar      func(childComplexity int, input *CarInput) int
		NewUser     func(childComplexity int, input *NewUser) int
		UpdateCar   func(childComplexity int, input *CarInput) int
	}

	NewUserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	Query struct {
		ListCars          func(childComplexity int, input *ListCars) int
		ListUser          func(childComplexity int, input *ListUser) int
		XgenIntrospection func(childComplexity int) int
	}

	Resource struct {
		Name    func(childComplexity int) int
		Primary func(childComplexity int) int
		Route   func(childComplexity int) int
	}

	ResourceAnnotationSingle struct {
		Name  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	User struct {
		Cars func(childComplexity int) int
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	UserXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenAnnotationMap struct {
		Action     func(childComplexity int) int
		ListAction func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenCursorPaginationInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenFieldDef struct {
		ActionField func(childComplexity int) int
		Field       func(childComplexity int) int
	}

	XgenIntrospection struct {
		Annotation func(childComplexity int) int
		Object     func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenObjectDefinition struct {
		Action     func(childComplexity int) int
		ListAction func(childComplexity int) int
		Resource   func(childComplexity int) int
	}

	XgenObjectField struct {
		Definition func(childComplexity int) int
		Name       func(childComplexity int) int
	}

	XgenObjectMap struct {
		Car                            func(childComplexity int) int
		CarInput                       func(childComplexity int) int
		DeleteUsers                    func(childComplexity int) int
		ListCars                       func(childComplexity int) int
		ListUser                       func(childComplexity int) int
		NewUser                        func(childComplexity int) int
		User                           func(childComplexity int) int
		XgenCursorPaginationInput      func(childComplexity int) int
		XgenPaginationInput            func(childComplexity int) int
		XgenResourceActionType         func(childComplexity int) int
		XgenResourceDbConfigInput      func(childComplexity int) int
		XgenResourceFieldDbConfigInput func(childComplexity int) int
		XgenResourceListActionType     func(childComplexity int) int
	}

	XgenPaginationInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceAction struct {
		Action          func(childComplexity int) int
		Resource        func(childComplexity int) int
		Route           func(childComplexity int) int
		SchemaFieldName func(childComplexity int) int
	}

	XgenResourceActionTypeXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceDbConfigInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceDefinition struct {
		Actions    func(childComplexity int) int
		ObjectName func(childComplexity int) int
		Properties func(childComplexity int) int
	}

	XgenResourceFieldDbConfigInputXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceListActionTypeXgenDef struct {
		Field  func(childComplexity int) int
		Object func(childComplexity int) int
	}

	XgenResourceMap struct {
		Car  func(childComplexity int) int
		User func(childComplexity int) int
	}

	XgenResourceProperty struct {
		Name    func(childComplexity int) int
		Primary func(childComplexity int) int
		Route   func(childComplexity int) int
	}
}

type MutationResolver interface {
	DeleteUsers(ctx context.Context, input *DeleteUsers) ([]*User, error)
	NewUser(ctx context.Context, input *NewUser) (*User, error)
	NewCar(ctx context.Context, input *CarInput) (*Car, error)
	UpdateCar(ctx context.Context, input *CarInput) (*Car, error)
}
type QueryResolver interface {
	XgenIntrospection(ctx context.Context) (*XgenIntrospection, error)
	ListUser(ctx context.Context, input *ListUser) ([]*User, error)
	ListCars(ctx context.Context, input *ListCars) ([]*Car, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Action.Action":
		if e.complexity.Action.Action == nil {
			break
		}

		return e.complexity.Action.Action(childComplexity), true

	case "Action.Resource":
		if e.complexity.Action.Resource == nil {
			break
		}

		return e.complexity.Action.Resource(childComplexity), true

	case "Action.Route":
		if e.complexity.Action.Route == nil {
			break
		}

		return e.complexity.Action.Route(childComplexity), true

	case "Action.SchemaFieldName":
		if e.complexity.Action.SchemaFieldName == nil {
			break
		}

		return e.complexity.Action.SchemaFieldName(childComplexity), true

	case "ActionAnnotationSingle.name":
		if e.complexity.ActionAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ActionAnnotationSingle.Name(childComplexity), true

	case "ActionAnnotationSingle.value":
		if e.complexity.ActionAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ActionAnnotationSingle.Value(childComplexity), true

	case "ActionField.Description":
		if e.complexity.ActionField.Description == nil {
			break
		}

		return e.complexity.ActionField.Description(childComplexity), true

	case "ActionField.Label":
		if e.complexity.ActionField.Label == nil {
			break
		}

		return e.complexity.ActionField.Label(childComplexity), true

	case "Car.done":
		if e.complexity.Car.Done == nil {
			break
		}

		return e.complexity.Car.Done(childComplexity), true

	case "Car.id":
		if e.complexity.Car.ID == nil {
			break
		}

		return e.complexity.Car.ID(childComplexity), true

	case "Car.make":
		if e.complexity.Car.Make == nil {
			break
		}

		return e.complexity.Car.Make(childComplexity), true

	case "Car.user":
		if e.complexity.Car.User == nil {
			break
		}

		return e.complexity.Car.User(childComplexity), true

	case "CarInputXgenDef.field":
		if e.complexity.CarInputXgenDef.Field == nil {
			break
		}

		return e.complexity.CarInputXgenDef.Field(childComplexity), true

	case "CarInputXgenDef.object":
		if e.complexity.CarInputXgenDef.Object == nil {
			break
		}

		return e.complexity.CarInputXgenDef.Object(childComplexity), true

	case "CarXgenDef.field":
		if e.complexity.CarXgenDef.Field == nil {
			break
		}

		return e.complexity.CarXgenDef.Field(childComplexity), true

	case "CarXgenDef.object":
		if e.complexity.CarXgenDef.Object == nil {
			break
		}

		return e.complexity.CarXgenDef.Object(childComplexity), true

	case "DeleteUsersXgenDef.field":
		if e.complexity.DeleteUsersXgenDef.Field == nil {
			break
		}

		return e.complexity.DeleteUsersXgenDef.Field(childComplexity), true

	case "DeleteUsersXgenDef.object":
		if e.complexity.DeleteUsersXgenDef.Object == nil {
			break
		}

		return e.complexity.DeleteUsersXgenDef.Object(childComplexity), true

	case "Field.Description":
		if e.complexity.Field.Description == nil {
			break
		}

		return e.complexity.Field.Description(childComplexity), true

	case "Field.Label":
		if e.complexity.Field.Label == nil {
			break
		}

		return e.complexity.Field.Label(childComplexity), true

	case "ListAction.Action":
		if e.complexity.ListAction.Action == nil {
			break
		}

		return e.complexity.ListAction.Action(childComplexity), true

	case "ListAction.Pagination":
		if e.complexity.ListAction.Pagination == nil {
			break
		}

		return e.complexity.ListAction.Pagination(childComplexity), true

	case "ListAction.Resource":
		if e.complexity.ListAction.Resource == nil {
			break
		}

		return e.complexity.ListAction.Resource(childComplexity), true

	case "ListAction.Route":
		if e.complexity.ListAction.Route == nil {
			break
		}

		return e.complexity.ListAction.Route(childComplexity), true

	case "ListAction.SchemaFieldName":
		if e.complexity.ListAction.SchemaFieldName == nil {
			break
		}

		return e.complexity.ListAction.SchemaFieldName(childComplexity), true

	case "ListActionAnnotationSingle.name":
		if e.complexity.ListActionAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ListActionAnnotationSingle.Name(childComplexity), true

	case "ListActionAnnotationSingle.value":
		if e.complexity.ListActionAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ListActionAnnotationSingle.Value(childComplexity), true

	case "ListCarsXgenDef.field":
		if e.complexity.ListCarsXgenDef.Field == nil {
			break
		}

		return e.complexity.ListCarsXgenDef.Field(childComplexity), true

	case "ListCarsXgenDef.object":
		if e.complexity.ListCarsXgenDef.Object == nil {
			break
		}

		return e.complexity.ListCarsXgenDef.Object(childComplexity), true

	case "ListUserXgenDef.field":
		if e.complexity.ListUserXgenDef.Field == nil {
			break
		}

		return e.complexity.ListUserXgenDef.Field(childComplexity), true

	case "ListUserXgenDef.object":
		if e.complexity.ListUserXgenDef.Object == nil {
			break
		}

		return e.complexity.ListUserXgenDef.Object(childComplexity), true

	case "Mutation.delete_users":
		if e.complexity.Mutation.DeleteUsers == nil {
			break
		}

		args, err := ec.field_Mutation_delete_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUsers(childComplexity, args["input"].(*DeleteUsers)), true

	case "Mutation.new_car":
		if e.complexity.Mutation.NewCar == nil {
			break
		}

		args, err := ec.field_Mutation_new_car_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewCar(childComplexity, args["input"].(*CarInput)), true

	case "Mutation.new_user":
		if e.complexity.Mutation.NewUser == nil {
			break
		}

		args, err := ec.field_Mutation_new_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewUser(childComplexity, args["input"].(*NewUser)), true

	case "Mutation.update_car":
		if e.complexity.Mutation.UpdateCar == nil {
			break
		}

		args, err := ec.field_Mutation_update_car_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCar(childComplexity, args["input"].(*CarInput)), true

	case "NewUserXgenDef.field":
		if e.complexity.NewUserXgenDef.Field == nil {
			break
		}

		return e.complexity.NewUserXgenDef.Field(childComplexity), true

	case "NewUserXgenDef.object":
		if e.complexity.NewUserXgenDef.Object == nil {
			break
		}

		return e.complexity.NewUserXgenDef.Object(childComplexity), true

	case "Query.list_cars":
		if e.complexity.Query.ListCars == nil {
			break
		}

		args, err := ec.field_Query_list_cars_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListCars(childComplexity, args["input"].(*ListCars)), true

	case "Query.list_user":
		if e.complexity.Query.ListUser == nil {
			break
		}

		args, err := ec.field_Query_list_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListUser(childComplexity, args["input"].(*ListUser)), true

	case "Query._xgen_introspection":
		if e.complexity.Query.XgenIntrospection == nil {
			break
		}

		return e.complexity.Query.XgenIntrospection(childComplexity), true

	case "Resource.Name":
		if e.complexity.Resource.Name == nil {
			break
		}

		return e.complexity.Resource.Name(childComplexity), true

	case "Resource.Primary":
		if e.complexity.Resource.Primary == nil {
			break
		}

		return e.complexity.Resource.Primary(childComplexity), true

	case "Resource.Route":
		if e.complexity.Resource.Route == nil {
			break
		}

		return e.complexity.Resource.Route(childComplexity), true

	case "ResourceAnnotationSingle.name":
		if e.complexity.ResourceAnnotationSingle.Name == nil {
			break
		}

		return e.complexity.ResourceAnnotationSingle.Name(childComplexity), true

	case "ResourceAnnotationSingle.value":
		if e.complexity.ResourceAnnotationSingle.Value == nil {
			break
		}

		return e.complexity.ResourceAnnotationSingle.Value(childComplexity), true

	case "User.cars":
		if e.complexity.User.Cars == nil {
			break
		}

		return e.complexity.User.Cars(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "UserXgenDef.field":
		if e.complexity.UserXgenDef.Field == nil {
			break
		}

		return e.complexity.UserXgenDef.Field(childComplexity), true

	case "UserXgenDef.object":
		if e.complexity.UserXgenDef.Object == nil {
			break
		}

		return e.complexity.UserXgenDef.Object(childComplexity), true

	case "XgenAnnotationMap.Action":
		if e.complexity.XgenAnnotationMap.Action == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.Action(childComplexity), true

	case "XgenAnnotationMap.ListAction":
		if e.complexity.XgenAnnotationMap.ListAction == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.ListAction(childComplexity), true

	case "XgenAnnotationMap.Resource":
		if e.complexity.XgenAnnotationMap.Resource == nil {
			break
		}

		return e.complexity.XgenAnnotationMap.Resource(childComplexity), true

	case "XgenCursorPaginationInputXgenDef.field":
		if e.complexity.XgenCursorPaginationInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenCursorPaginationInputXgenDef.Field(childComplexity), true

	case "XgenCursorPaginationInputXgenDef.object":
		if e.complexity.XgenCursorPaginationInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenCursorPaginationInputXgenDef.Object(childComplexity), true

	case "XgenFieldDef.ActionField":
		if e.complexity.XgenFieldDef.ActionField == nil {
			break
		}

		return e.complexity.XgenFieldDef.ActionField(childComplexity), true

	case "XgenFieldDef.Field":
		if e.complexity.XgenFieldDef.Field == nil {
			break
		}

		return e.complexity.XgenFieldDef.Field(childComplexity), true

	case "XgenIntrospection.annotation":
		if e.complexity.XgenIntrospection.Annotation == nil {
			break
		}

		return e.complexity.XgenIntrospection.Annotation(childComplexity), true

	case "XgenIntrospection.object":
		if e.complexity.XgenIntrospection.Object == nil {
			break
		}

		return e.complexity.XgenIntrospection.Object(childComplexity), true

	case "XgenIntrospection.resource":
		if e.complexity.XgenIntrospection.Resource == nil {
			break
		}

		return e.complexity.XgenIntrospection.Resource(childComplexity), true

	case "XgenObjectDefinition.Action":
		if e.complexity.XgenObjectDefinition.Action == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.Action(childComplexity), true

	case "XgenObjectDefinition.ListAction":
		if e.complexity.XgenObjectDefinition.ListAction == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.ListAction(childComplexity), true

	case "XgenObjectDefinition.Resource":
		if e.complexity.XgenObjectDefinition.Resource == nil {
			break
		}

		return e.complexity.XgenObjectDefinition.Resource(childComplexity), true

	case "XgenObjectField.definition":
		if e.complexity.XgenObjectField.Definition == nil {
			break
		}

		return e.complexity.XgenObjectField.Definition(childComplexity), true

	case "XgenObjectField.name":
		if e.complexity.XgenObjectField.Name == nil {
			break
		}

		return e.complexity.XgenObjectField.Name(childComplexity), true

	case "XgenObjectMap.Car":
		if e.complexity.XgenObjectMap.Car == nil {
			break
		}

		return e.complexity.XgenObjectMap.Car(childComplexity), true

	case "XgenObjectMap.CarInput":
		if e.complexity.XgenObjectMap.CarInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.CarInput(childComplexity), true

	case "XgenObjectMap.DeleteUsers":
		if e.complexity.XgenObjectMap.DeleteUsers == nil {
			break
		}

		return e.complexity.XgenObjectMap.DeleteUsers(childComplexity), true

	case "XgenObjectMap.ListCars":
		if e.complexity.XgenObjectMap.ListCars == nil {
			break
		}

		return e.complexity.XgenObjectMap.ListCars(childComplexity), true

	case "XgenObjectMap.ListUser":
		if e.complexity.XgenObjectMap.ListUser == nil {
			break
		}

		return e.complexity.XgenObjectMap.ListUser(childComplexity), true

	case "XgenObjectMap.NewUser":
		if e.complexity.XgenObjectMap.NewUser == nil {
			break
		}

		return e.complexity.XgenObjectMap.NewUser(childComplexity), true

	case "XgenObjectMap.User":
		if e.complexity.XgenObjectMap.User == nil {
			break
		}

		return e.complexity.XgenObjectMap.User(childComplexity), true

	case "XgenObjectMap.XgenCursorPaginationInput":
		if e.complexity.XgenObjectMap.XgenCursorPaginationInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenCursorPaginationInput(childComplexity), true

	case "XgenObjectMap.XgenPaginationInput":
		if e.complexity.XgenObjectMap.XgenPaginationInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenPaginationInput(childComplexity), true

	case "XgenObjectMap.XgenResourceActionType":
		if e.complexity.XgenObjectMap.XgenResourceActionType == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceActionType(childComplexity), true

	case "XgenObjectMap.XgenResourceDbConfigInput":
		if e.complexity.XgenObjectMap.XgenResourceDbConfigInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceDbConfigInput(childComplexity), true

	case "XgenObjectMap.XgenResourceFieldDbConfigInput":
		if e.complexity.XgenObjectMap.XgenResourceFieldDbConfigInput == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceFieldDbConfigInput(childComplexity), true

	case "XgenObjectMap.XgenResourceListActionType":
		if e.complexity.XgenObjectMap.XgenResourceListActionType == nil {
			break
		}

		return e.complexity.XgenObjectMap.XgenResourceListActionType(childComplexity), true

	case "XgenPaginationInputXgenDef.field":
		if e.complexity.XgenPaginationInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenPaginationInputXgenDef.Field(childComplexity), true

	case "XgenPaginationInputXgenDef.object":
		if e.complexity.XgenPaginationInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenPaginationInputXgenDef.Object(childComplexity), true

	case "XgenResourceAction.Action":
		if e.complexity.XgenResourceAction.Action == nil {
			break
		}

		return e.complexity.XgenResourceAction.Action(childComplexity), true

	case "XgenResourceAction.Resource":
		if e.complexity.XgenResourceAction.Resource == nil {
			break
		}

		return e.complexity.XgenResourceAction.Resource(childComplexity), true

	case "XgenResourceAction.Route":
		if e.complexity.XgenResourceAction.Route == nil {
			break
		}

		return e.complexity.XgenResourceAction.Route(childComplexity), true

	case "XgenResourceAction.SchemaFieldName":
		if e.complexity.XgenResourceAction.SchemaFieldName == nil {
			break
		}

		return e.complexity.XgenResourceAction.SchemaFieldName(childComplexity), true

	case "XgenResourceActionTypeXgenDef.field":
		if e.complexity.XgenResourceActionTypeXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceActionTypeXgenDef.Field(childComplexity), true

	case "XgenResourceActionTypeXgenDef.object":
		if e.complexity.XgenResourceActionTypeXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceActionTypeXgenDef.Object(childComplexity), true

	case "XgenResourceDbConfigInputXgenDef.field":
		if e.complexity.XgenResourceDbConfigInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceDbConfigInputXgenDef.Field(childComplexity), true

	case "XgenResourceDbConfigInputXgenDef.object":
		if e.complexity.XgenResourceDbConfigInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceDbConfigInputXgenDef.Object(childComplexity), true

	case "XgenResourceDefinition.actions":
		if e.complexity.XgenResourceDefinition.Actions == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.Actions(childComplexity), true

	case "XgenResourceDefinition.objectName":
		if e.complexity.XgenResourceDefinition.ObjectName == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.ObjectName(childComplexity), true

	case "XgenResourceDefinition.properties":
		if e.complexity.XgenResourceDefinition.Properties == nil {
			break
		}

		return e.complexity.XgenResourceDefinition.Properties(childComplexity), true

	case "XgenResourceFieldDbConfigInputXgenDef.field":
		if e.complexity.XgenResourceFieldDbConfigInputXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceFieldDbConfigInputXgenDef.Field(childComplexity), true

	case "XgenResourceFieldDbConfigInputXgenDef.object":
		if e.complexity.XgenResourceFieldDbConfigInputXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceFieldDbConfigInputXgenDef.Object(childComplexity), true

	case "XgenResourceListActionTypeXgenDef.field":
		if e.complexity.XgenResourceListActionTypeXgenDef.Field == nil {
			break
		}

		return e.complexity.XgenResourceListActionTypeXgenDef.Field(childComplexity), true

	case "XgenResourceListActionTypeXgenDef.object":
		if e.complexity.XgenResourceListActionTypeXgenDef.Object == nil {
			break
		}

		return e.complexity.XgenResourceListActionTypeXgenDef.Object(childComplexity), true

	case "XgenResourceMap.car":
		if e.complexity.XgenResourceMap.Car == nil {
			break
		}

		return e.complexity.XgenResourceMap.Car(childComplexity), true

	case "XgenResourceMap.user":
		if e.complexity.XgenResourceMap.User == nil {
			break
		}

		return e.complexity.XgenResourceMap.User(childComplexity), true

	case "XgenResourceProperty.Name":
		if e.complexity.XgenResourceProperty.Name == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Name(childComplexity), true

	case "XgenResourceProperty.Primary":
		if e.complexity.XgenResourceProperty.Primary == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Primary(childComplexity), true

	case "XgenResourceProperty.Route":
		if e.complexity.XgenResourceProperty.Route == nil {
			break
		}

		return e.complexity.XgenResourceProperty.Route(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCarInput,
		ec.unmarshalInputDeleteUsers,
		ec.unmarshalInputListCars,
		ec.unmarshalInputListUser,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputXgenCursorPaginationInput,
		ec.unmarshalInputXgenPaginationInput,
		ec.unmarshalInputXgenResourceDbConfigInput,
		ec.unmarshalInputXgenResourceFieldDbConfigInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.main.graphql", Input: `type User
@Resource(Name: "user", Primary: true, Route: "user", DB: {Table: "user"})
{
    id: ID! @Field(Label: "ID", Description: "ID of the todo", DB: {Column: "id", PrimaryKey: true})
    name: String! @Field(Label: "Text", Description: "Text of the todo", DB: {Column: "name", Unique: true})
    cars: [Car!]! @Field(Label: "Cars", Description: "Cars of the todo", DB: {})
}

type Car
@Resource(Name: "car", Primary: true, Route: "car", DB: {Table: "car"})
{
    id: ID! @Field(Label: "ID", Description: "ID of the todo", DB: {Column: "id", PrimaryKey: true})
    make: String! @Field(Label: "Make", Description: "Car make", DB: {Column: "make"})
    done: Boolean! @Field(Label: "Done", Description: "Done of the todo", DB: {Column: "done"})
    user: User! @Field(Label: "User", Description: "User of the todo", DB: {})
}

input CarInput
@Action(Resource: "car", Action: CREATE_MUTATION, Route: "new", SchemaFieldName: "new_car")
@Action(Resource: "car", Action: UPDATE_MUTATION, Route: "update", SchemaFieldName: "update_car")
{
    id: ID @ActionField(Label: "ID", Description: "ID of the todo")
    make: String @ActionField(Label: "Make", Description: "Text of the todo")
    done: Boolean @ActionField(Label: "Done", Description: "Done of the todo")
    user: ID @ActionField(Label: "User", Description: "User of the todo")
}

input NewUser
@Action(Resource: "user", Action: CREATE_MUTATION, Route: "new", SchemaFieldName: "new_user")
{
    name: String! @ActionField(Label: "Name", Description: "Name")
    cars: [CarInput!] @ActionField(Label: "Cars", Description: "Cars of the todo")
}

input DeleteUsers
@ListAction(Resource: "user", Action: BATCH_DELETE_MUTATION, Route: "delete", SchemaFieldName: "delete_users")
{
    ids: [ID!] @ActionField(Label: "IDs", Description: "IDs of users")
}

input ListUser
@ListAction(Resource: "user", Action: BROWSE_QUERY, Route: "list", SchemaFieldName: "list_user")
{
    id: ID @ActionField(Label: "ID", Description: "ID")
    name: String @ActionField(Label: "Name", Description: "Name")
}

input ListCars
@ListAction(Resource: "car", Action: BROWSE_QUERY, Route: "list", SchemaFieldName: "list_cars")
{
    id: ID @ActionField(Label: "ID", Description: "ID")
    userId: ID @ActionField(Label: "User ID", Description: "User ID")
    make: String @ActionField(Label: "Make", Description: "Make")
}`, BuiltIn: false},
	{Name: "../generated_xgen_directives.graphql", Input: `"""This directive is used to mark the object as a resource"""
directive @Resource(Name: String!, Route: String, Primary: Boolean, DB: XgenResourceDbConfigInput @ExcludeArgumentFromType) on OBJECT
"""This directive is used to mark the object as a resource action"""
directive @Action(Resource: String!, Action: XgenResourceActionType!, Route: String, SchemaFieldName: String) repeatable on INPUT_OBJECT
"""This directive is used to mark the object as a resource list action"""
directive @ListAction(Resource: String!, Action: XgenResourceListActionType!, Route: String, Pagination: Boolean, SchemaFieldName: String) repeatable on INPUT_OBJECT
"""This directive is used to exclude the argument from the type"""
directive @ExcludeArgumentFromType(exclude: Boolean) on ARGUMENT_DEFINITION
"""This directive is used to mark the object as a resource field"""
directive @Field(Label: String, Description: String, DB: XgenResourceFieldDbConfigInput @ExcludeArgumentFromType) on FIELD_DEFINITION
"""This directive is used to mark the object as a resource field"""
directive @ActionField(Label: String, Description: String) on INPUT_FIELD_DEFINITION
enum XgenResourceActionType {
  CREATE_MUTATION
  READ_QUERY
  UPDATE_MUTATION
  DELETE_MUTATION
}
enum XgenResourceListActionType {
  BROWSE_QUERY
  BATCH_DELETE_MUTATION
}
input XgenPaginationInput {
  page: Int!
  limit: Int!
}
input XgenCursorPaginationInput {
  first: Int!
  after: String
  last: Int!
  before: String
}
input XgenResourceDbConfigInput {
  Table: String
}
input XgenResourceFieldDbConfigInput {
  Column: String
  PrimaryKey: Boolean
  AutoIncrement: Boolean
  Unique: Boolean
  NotNull: Boolean
  Index: Boolean
  UniqueIndex: Boolean
  Size: Int
  Precision: Int
  Type: String
  Scale: Int
  AutoIncrementIncrement: Int
}`, BuiltIn: false},
	{Name: "../../schema", Input: `type XgenIntrospection {
  annotation: XgenAnnotationMap
  object: XgenObjectMap
  resource: XgenResourceMap
}
"""This directive is used to mark the object as a resource list action"""
type ListAction {
  Resource: String!
  Action: XgenResourceListActionType!
  Route: String
  Pagination: Boolean
  SchemaFieldName: String
}
"""This directive is used to mark the object as a resource field"""
type Field {
  Label: String
  Description: String
}
"""This directive is used to mark the object as a resource"""
type Resource {
  Name: String!
  Route: String
  Primary: Boolean
}
"""This directive is used to mark the object as a resource action"""
type Action {
  Resource: String!
  Action: XgenResourceActionType!
  Route: String
  SchemaFieldName: String
}
"""This directive is used to mark the object as a resource field"""
type ActionField {
  Label: String
  Description: String
}
type XgenAnnotationMap {
  Action: [ActionAnnotationSingle!]!
  Resource: [ResourceAnnotationSingle!]!
  ListAction: [ListActionAnnotationSingle!]!
}
type ActionAnnotationSingle {
  name: String
  value: Action
}
type ResourceAnnotationSingle {
  name: String
  value: Resource
}
type ListActionAnnotationSingle {
  name: String
  value: ListAction
}
type XgenFieldDef {
  Field: Field
  ActionField: ActionField
}
type XgenObjectDefinition {
  Resource: Resource
  ListAction: ListAction
  Action: Action
}
type XgenObjectField {
  name: String
  definition: XgenFieldDef
}
type XgenObjectMap {
  XgenResourceListActionType: XgenResourceListActionTypeXgenDef
  Car: CarXgenDef
  CarInput: CarInputXgenDef
  XgenResourceActionType: XgenResourceActionTypeXgenDef
  ListCars: ListCarsXgenDef
  XgenResourceFieldDbConfigInput: XgenResourceFieldDbConfigInputXgenDef
  XgenCursorPaginationInput: XgenCursorPaginationInputXgenDef
  DeleteUsers: DeleteUsersXgenDef
  User: UserXgenDef
  NewUser: NewUserXgenDef
  ListUser: ListUserXgenDef
  XgenPaginationInput: XgenPaginationInputXgenDef
  XgenResourceDbConfigInput: XgenResourceDbConfigInputXgenDef
}
type XgenResourceListActionTypeXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type CarXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type CarInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceActionTypeXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type ListCarsXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceFieldDbConfigInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenCursorPaginationInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type DeleteUsersXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type UserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type NewUserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type ListUserXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenPaginationInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceDbConfigInputXgenDef {
  object: XgenObjectDefinition
  field: [XgenObjectField!]!
}
type XgenResourceMap {
  car: XgenResourceDefinition
  user: XgenResourceDefinition
}
type XgenResourceDefinition {
  objectName: String
  properties: XgenResourceProperty
  actions: [XgenResourceAction]!
}
type XgenResourceProperty {
  Name: String!
  Route: String
  Primary: Boolean
}
type XgenResourceAction {
  Resource: String!
  Action: XgenResourceActionType!
  Route: String
  SchemaFieldName: String
}
extend type Query {
  _xgen_introspection: XgenIntrospection
}
extend type Query {
  list_user(input: ListUser): [User]!
  list_cars(input: ListCars): [Car]!
}
extend type Mutation {
  delete_users(input: DeleteUsers): [User]!
  new_user(input: NewUser): User
  new_car(input: CarInput): Car
  update_car(input: CarInput): Car
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_ActionField_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Label"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Label"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Label"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	return args, nil
}

func (ec *executionContext) dir_Action_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Resource"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Resource"] = arg0
	var arg1 XgenResourceActionType
	if tmp, ok := rawArgs["Action"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Action"))
		arg1, err = ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Action"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["SchemaFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("SchemaFieldName"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["SchemaFieldName"] = arg3
	return args, nil
}

func (ec *executionContext) dir_ExcludeArgumentFromType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["exclude"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude"))
		arg0, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["exclude"] = arg0
	return args, nil
}

func (ec *executionContext) dir_Field_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["Label"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Label"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Label"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Description"] = arg1
	var arg2 *XgenResourceFieldDbConfigInput
	if tmp, ok := rawArgs["DB"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("DB"))
		arg2, err = ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["DB"] = arg2
	return args, nil
}

func (ec *executionContext) dir_ListAction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Resource"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Resource"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Resource"] = arg0
	var arg1 XgenResourceListActionType
	if tmp, ok := rawArgs["Action"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Action"))
		arg1, err = ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Action"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["Pagination"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Pagination"))
		arg3, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Pagination"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["SchemaFieldName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("SchemaFieldName"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["SchemaFieldName"] = arg4
	return args, nil
}

func (ec *executionContext) dir_Resource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["Name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["Route"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Route"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Route"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["Primary"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Primary"))
		arg2, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["Primary"] = arg2
	var arg3 *XgenResourceDbConfigInput
	if tmp, ok := rawArgs["DB"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("DB"))
		arg3, err = ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["DB"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_delete_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DeleteUsers
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteUsers2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐDeleteUsers(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_new_car_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CarInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCarInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_new_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *NewUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalONewUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐNewUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_update_car_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *CarInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCarInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_list_cars_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListCars
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListCars2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListCars(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_list_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ListUser
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOListUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListUser(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Action_Resource(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_Action(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceActionType)
	fc.Result = res
	return ec.marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_Route(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Action_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *Action) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Action_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Action_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Action",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Action)
	fc.Result = res
	return ec.marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_Action_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_Action_Action(ctx, field)
			case "Route":
				return ec.fieldContext_Action_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_Action_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Action", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionField_Label(ctx context.Context, field graphql.CollectedField, obj *ActionField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionField_Label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionField_Label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionField_Description(ctx context.Context, field graphql.CollectedField, obj *ActionField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ActionField_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ActionField_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Car_id(ctx context.Context, field graphql.CollectedField, obj *Car) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Car_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "ID of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "id", "PrimaryKey": true})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive0, label, description, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Car_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Car",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Car_make(ctx context.Context, field graphql.CollectedField, obj *Car) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Car_make(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Make, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Make")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Car make")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "make"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive0, label, description, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Car_make(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Car",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Car_done(ctx context.Context, field graphql.CollectedField, obj *Car) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Car_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Done, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Done")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Done of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "done"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive0, label, description, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Car_done(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Car",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Car_user(ctx context.Context, field graphql.CollectedField, obj *Car) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Car_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.User, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "user")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "user"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, obj, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "User")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "User of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive1, label, description, db)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/internal/integration/gormproj/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Car_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Car",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "cars":
				return ec.fieldContext_User_cars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CarInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *CarInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CarInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CarInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CarInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CarInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *CarInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CarInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CarInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CarInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CarXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *CarXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CarXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CarXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CarXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CarXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *CarXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CarXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CarXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CarXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteUsersXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *DeleteUsersXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteUsersXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteUsersXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteUsersXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteUsersXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *DeleteUsersXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteUsersXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteUsersXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteUsersXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Field_Label(ctx context.Context, field graphql.CollectedField, obj *Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Field_Label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Field_Label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Field_Description(ctx context.Context, field graphql.CollectedField, obj *Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Field_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Field_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Resource(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Action(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceListActionType)
	fc.Result = res
	return ec.marshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceListActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Route(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_Pagination(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_Pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_Pagination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *ListAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ListActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListActionAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListActionAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ListActionAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListActionAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListAction)
	fc.Result = res
	return ec.marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListActionAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListActionAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_ListAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_ListAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_ListAction_Route(ctx, field)
			case "Pagination":
				return ec.fieldContext_ListAction_Pagination(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListCarsXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *ListCarsXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListCarsXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListCarsXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListCarsXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListCarsXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *ListCarsXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListCarsXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListCarsXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListCarsXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListUserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *ListUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListUserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListUserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ListUserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *ListUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ListUserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ListUserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ListUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_delete_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_delete_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUsers(rctx, fc.Args["input"].(*DeleteUsers))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "user")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "user"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/internal/integration/gormproj/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_delete_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "cars":
				return ec.fieldContext_User_cars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_delete_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_new_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_new_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().NewUser(rctx, fc.Args["input"].(*NewUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "user")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "user"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/internal/integration/gormproj/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_new_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "cars":
				return ec.fieldContext_User_cars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_new_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_new_car(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_new_car(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().NewCar(rctx, fc.Args["input"].(*CarInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "car")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "car")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "car"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Car); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/internal/integration/gormproj/generated.Car`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Car)
	fc.Result = res
	return ec.marshalOCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_new_car(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Car_id(ctx, field)
			case "make":
				return ec.fieldContext_Car_make(ctx, field)
			case "done":
				return ec.fieldContext_Car_done(ctx, field)
			case "user":
				return ec.fieldContext_Car_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Car", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_new_car_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_update_car(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_update_car(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCar(rctx, fc.Args["input"].(*CarInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "car")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "car")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "car"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Car); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/goxgen/goxgen/internal/integration/gormproj/generated.Car`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Car)
	fc.Result = res
	return ec.marshalOCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_update_car(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Car_id(ctx, field)
			case "make":
				return ec.fieldContext_Car_make(ctx, field)
			case "done":
				return ec.fieldContext_Car_done(ctx, field)
			case "user":
				return ec.fieldContext_Car_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Car", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_update_car_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NewUserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *NewUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewUserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewUserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewUserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *NewUserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewUserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewUserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewUserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query__xgen_introspection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__xgen_introspection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().XgenIntrospection(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenIntrospection)
	fc.Result = res
	return ec.marshalOXgenIntrospection2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenIntrospection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__xgen_introspection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "annotation":
				return ec.fieldContext_XgenIntrospection_annotation(ctx, field)
			case "object":
				return ec.fieldContext_XgenIntrospection_object(ctx, field)
			case "resource":
				return ec.fieldContext_XgenIntrospection_resource(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenIntrospection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_list_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_list_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListUser(rctx, fc.Args["input"].(*ListUser))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "user")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "user")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "user"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/internal/integration/gormproj/generated.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_list_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "cars":
				return ec.fieldContext_User_cars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_list_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_list_cars(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_list_cars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListCars(rctx, fc.Args["input"].(*ListCars))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "car")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "car")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "car"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, nil, directive0, name, route, primary, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Car); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/internal/integration/gormproj/generated.Car`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Car)
	fc.Result = res
	return ec.marshalNCar2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_list_cars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Car_id(ctx, field)
			case "make":
				return ec.fieldContext_Car_make(ctx, field)
			case "done":
				return ec.fieldContext_Car_done(ctx, field)
			case "user":
				return ec.fieldContext_Car_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Car", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_list_cars_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Name(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Route(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Primary(ctx context.Context, field graphql.CollectedField, obj *Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Primary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Primary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceAnnotationSingle_name(ctx context.Context, field graphql.CollectedField, obj *ResourceAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceAnnotationSingle_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceAnnotationSingle_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceAnnotationSingle_value(ctx context.Context, field graphql.CollectedField, obj *ResourceAnnotationSingle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceAnnotationSingle_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Resource)
	fc.Result = res
	return ec.marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceAnnotationSingle_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceAnnotationSingle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_Resource_Name(ctx, field)
			case "Route":
				return ec.fieldContext_Resource_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_Resource_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ID, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "ID of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "id", "PrimaryKey": true})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive0, label, description, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Text")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Text of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{"Column": "name", "Unique": true})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive0, label, description, db)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_cars(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_cars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Cars, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			name, err := ec.unmarshalNString2string(ctx, "car")
			if err != nil {
				return nil, err
			}
			route, err := ec.unmarshalOString2ᚖstring(ctx, "car")
			if err != nil {
				return nil, err
			}
			primary, err := ec.unmarshalOBoolean2ᚖbool(ctx, true)
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx, map[string]interface{}{"Table": "car"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Resource == nil {
				return nil, errors.New("directive Resource is not implemented")
			}
			return ec.directives.Resource(ctx, obj, directive0, name, route, primary, db)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			label, err := ec.unmarshalOString2ᚖstring(ctx, "Cars")
			if err != nil {
				return nil, err
			}
			description, err := ec.unmarshalOString2ᚖstring(ctx, "Cars of the todo")
			if err != nil {
				return nil, err
			}
			db, err := ec.unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx, map[string]interface{}{})
			if err != nil {
				return nil, err
			}
			if ec.directives.Field == nil {
				return nil, errors.New("directive Field is not implemented")
			}
			return ec.directives.Field(ctx, obj, directive1, label, description, db)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Car); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/internal/integration/gormproj/generated.Car`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Car)
	fc.Result = res
	return ec.marshalNCar2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_cars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Car_id(ctx, field)
			case "make":
				return ec.fieldContext_Car_make(ctx, field)
			case "done":
				return ec.fieldContext_Car_done(ctx, field)
			case "user":
				return ec.fieldContext_Car_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Car", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *UserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *UserXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_Action(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ActionAnnotationSingle)
	fc.Result = res
	return ec.marshalNActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ActionAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ActionAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActionAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ResourceAnnotationSingle)
	fc.Result = res
	return ec.marshalNResourceAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResourceAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ResourceAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ResourceAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenAnnotationMap_ListAction(ctx context.Context, field graphql.CollectedField, obj *XgenAnnotationMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenAnnotationMap_ListAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ListActionAnnotationSingle)
	fc.Result = res
	return ec.marshalNListActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListActionAnnotationSingleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenAnnotationMap_ListAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenAnnotationMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ListActionAnnotationSingle_name(ctx, field)
			case "value":
				return ec.fieldContext_ListActionAnnotationSingle_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListActionAnnotationSingle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenCursorPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenCursorPaginationInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenCursorPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenCursorPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenCursorPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenCursorPaginationInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenCursorPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenCursorPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenFieldDef_Field(ctx context.Context, field graphql.CollectedField, obj *XgenFieldDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenFieldDef_Field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Field)
	fc.Result = res
	return ec.marshalOField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenFieldDef_Field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenFieldDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Label":
				return ec.fieldContext_Field_Label(ctx, field)
			case "Description":
				return ec.fieldContext_Field_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Field", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenFieldDef_ActionField(ctx context.Context, field graphql.CollectedField, obj *XgenFieldDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenFieldDef_ActionField(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActionField, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ActionField)
	fc.Result = res
	return ec.marshalOActionField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenFieldDef_ActionField(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenFieldDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Label":
				return ec.fieldContext_ActionField_Label(ctx, field)
			case "Description":
				return ec.fieldContext_ActionField_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActionField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_annotation(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenAnnotationMap)
	fc.Result = res
	return ec.marshalOXgenAnnotationMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenAnnotationMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_annotation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Action":
				return ec.fieldContext_XgenAnnotationMap_Action(ctx, field)
			case "Resource":
				return ec.fieldContext_XgenAnnotationMap_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenAnnotationMap_ListAction(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenAnnotationMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_object(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectMap)
	fc.Result = res
	return ec.marshalOXgenObjectMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "XgenResourceListActionType":
				return ec.fieldContext_XgenObjectMap_XgenResourceListActionType(ctx, field)
			case "Car":
				return ec.fieldContext_XgenObjectMap_Car(ctx, field)
			case "CarInput":
				return ec.fieldContext_XgenObjectMap_CarInput(ctx, field)
			case "XgenResourceActionType":
				return ec.fieldContext_XgenObjectMap_XgenResourceActionType(ctx, field)
			case "ListCars":
				return ec.fieldContext_XgenObjectMap_ListCars(ctx, field)
			case "XgenResourceFieldDbConfigInput":
				return ec.fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field)
			case "XgenCursorPaginationInput":
				return ec.fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx, field)
			case "DeleteUsers":
				return ec.fieldContext_XgenObjectMap_DeleteUsers(ctx, field)
			case "User":
				return ec.fieldContext_XgenObjectMap_User(ctx, field)
			case "NewUser":
				return ec.fieldContext_XgenObjectMap_NewUser(ctx, field)
			case "ListUser":
				return ec.fieldContext_XgenObjectMap_ListUser(ctx, field)
			case "XgenPaginationInput":
				return ec.fieldContext_XgenObjectMap_XgenPaginationInput(ctx, field)
			case "XgenResourceDbConfigInput":
				return ec.fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenIntrospection_resource(ctx context.Context, field graphql.CollectedField, obj *XgenIntrospection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenIntrospection_resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceMap)
	fc.Result = res
	return ec.marshalOXgenResourceMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenIntrospection_resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenIntrospection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "car":
				return ec.fieldContext_XgenResourceMap_car(ctx, field)
			case "user":
				return ec.fieldContext_XgenResourceMap_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Resource)
	fc.Result = res
	return ec.marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_Resource_Name(ctx, field)
			case "Route":
				return ec.fieldContext_Resource_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_Resource_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_ListAction(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListAction)
	fc.Result = res
	return ec.marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_ListAction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_ListAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_ListAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_ListAction_Route(ctx, field)
			case "Pagination":
				return ec.fieldContext_ListAction_Pagination(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_ListAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectDefinition_Action(ctx context.Context, field graphql.CollectedField, obj *XgenObjectDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Action)
	fc.Result = res
	return ec.marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectDefinition_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_Action_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_Action_Action(ctx, field)
			case "Route":
				return ec.fieldContext_Action_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_Action_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Action", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectField_name(ctx context.Context, field graphql.CollectedField, obj *XgenObjectField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectField_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectField_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectField_definition(ctx context.Context, field graphql.CollectedField, obj *XgenObjectField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectField_definition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Definition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenFieldDef)
	fc.Result = res
	return ec.marshalOXgenFieldDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenFieldDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectField_definition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Field":
				return ec.fieldContext_XgenFieldDef_Field(ctx, field)
			case "ActionField":
				return ec.fieldContext_XgenFieldDef_ActionField(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenFieldDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceListActionType(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceListActionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceListActionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceListActionTypeXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceListActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionTypeXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceListActionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceListActionTypeXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceListActionTypeXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceListActionTypeXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_Car(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_Car(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Car, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CarXgenDef)
	fc.Result = res
	return ec.marshalOCarXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_Car(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_CarXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_CarXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CarXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_CarInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_CarInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CarInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CarInputXgenDef)
	fc.Result = res
	return ec.marshalOCarInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_CarInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_CarInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_CarInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CarInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceActionType(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceActionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceActionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceActionTypeXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionTypeXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceActionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceActionTypeXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceActionTypeXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceActionTypeXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_ListCars(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_ListCars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListCars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListCarsXgenDef)
	fc.Result = res
	return ec.marshalOListCarsXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListCarsXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_ListCars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_ListCarsXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_ListCarsXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListCarsXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceFieldDbConfigInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceFieldDbConfigInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceFieldDbConfigInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceFieldDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceFieldDbConfigInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceFieldDbConfigInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenCursorPaginationInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenCursorPaginationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenCursorPaginationInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenCursorPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenCursorPaginationInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenCursorPaginationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenCursorPaginationInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenCursorPaginationInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenCursorPaginationInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_DeleteUsers(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_DeleteUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteUsersXgenDef)
	fc.Result = res
	return ec.marshalODeleteUsersXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐDeleteUsersXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_DeleteUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_DeleteUsersXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_DeleteUsersXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteUsersXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_User(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_User(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserXgenDef)
	fc.Result = res
	return ec.marshalOUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_User(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_UserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_UserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_NewUser(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_NewUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NewUserXgenDef)
	fc.Result = res
	return ec.marshalONewUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐNewUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_NewUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_NewUserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_NewUserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewUserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_ListUser(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_ListUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ListUserXgenDef)
	fc.Result = res
	return ec.marshalOListUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListUserXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_ListUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_ListUserXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_ListUserXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ListUserXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenPaginationInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenPaginationInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenPaginationInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenPaginationInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenPaginationInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenPaginationInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenPaginationInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenPaginationInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenPaginationInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenObjectMap_XgenResourceDbConfigInput(ctx context.Context, field graphql.CollectedField, obj *XgenObjectMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.XgenResourceDbConfigInput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDbConfigInputXgenDef)
	fc.Result = res
	return ec.marshalOXgenResourceDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInputXgenDef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenObjectMap_XgenResourceDbConfigInput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenObjectMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "object":
				return ec.fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx, field)
			case "field":
				return ec.fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDbConfigInputXgenDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenPaginationInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenPaginationInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenPaginationInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenPaginationInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenPaginationInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenPaginationInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Resource(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Resource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Resource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Action(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(XgenResourceActionType)
	fc.Result = res
	return ec.marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Action(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type XgenResourceActionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_Route(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField, obj *XgenResourceAction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceAction_SchemaFieldName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchemaFieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceAction_SchemaFieldName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceActionTypeXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceActionTypeXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_objectName(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObjectName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_objectName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_properties(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceProperty)
	fc.Result = res
	return ec.marshalOXgenResourceProperty2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_XgenResourceProperty_Name(ctx, field)
			case "Route":
				return ec.fieldContext_XgenResourceProperty_Route(ctx, field)
			case "Primary":
				return ec.fieldContext_XgenResourceProperty_Primary(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceProperty", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceDefinition_actions(ctx context.Context, field graphql.CollectedField, obj *XgenResourceDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Actions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenResourceAction)
	fc.Result = res
	return ec.marshalNXgenResourceAction2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceDefinition_actions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceDefinition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenResourceAction_Resource(ctx, field)
			case "Action":
				return ec.fieldContext_XgenResourceAction_Action(ctx, field)
			case "Route":
				return ec.fieldContext_XgenResourceAction_Route(ctx, field)
			case "SchemaFieldName":
				return ec.fieldContext_XgenResourceAction_SchemaFieldName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceFieldDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceFieldDbConfigInputXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceFieldDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceFieldDbConfigInputXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceFieldDbConfigInputXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceFieldDbConfigInputXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField, obj *XgenResourceListActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceListActionTypeXgenDef_object(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Object, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenObjectDefinition)
	fc.Result = res
	return ec.marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceListActionTypeXgenDef_object(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceListActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Resource":
				return ec.fieldContext_XgenObjectDefinition_Resource(ctx, field)
			case "ListAction":
				return ec.fieldContext_XgenObjectDefinition_ListAction(ctx, field)
			case "Action":
				return ec.fieldContext_XgenObjectDefinition_Action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField, obj *XgenResourceListActionTypeXgenDef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceListActionTypeXgenDef_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*XgenObjectField)
	fc.Result = res
	return ec.marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceListActionTypeXgenDef_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceListActionTypeXgenDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_XgenObjectField_name(ctx, field)
			case "definition":
				return ec.fieldContext_XgenObjectField_definition(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenObjectField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceMap_car(ctx context.Context, field graphql.CollectedField, obj *XgenResourceMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceMap_car(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Car, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDefinition)
	fc.Result = res
	return ec.marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceMap_car(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "objectName":
				return ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
			case "properties":
				return ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
			case "actions":
				return ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceMap_user(ctx context.Context, field graphql.CollectedField, obj *XgenResourceMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceMap_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*XgenResourceDefinition)
	fc.Result = res
	return ec.marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceMap_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "objectName":
				return ec.fieldContext_XgenResourceDefinition_objectName(ctx, field)
			case "properties":
				return ec.fieldContext_XgenResourceDefinition_properties(ctx, field)
			case "actions":
				return ec.fieldContext_XgenResourceDefinition_actions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type XgenResourceDefinition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Name(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Route(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _XgenResourceProperty_Primary(ctx context.Context, field graphql.CollectedField, obj *XgenResourceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_XgenResourceProperty_Primary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_XgenResourceProperty_Primary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "XgenResourceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCarInput(ctx context.Context, obj interface{}) (CarInput, error) {
	var it CarInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "make", "done", "user"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "update")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "update_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive1, resource, action, route, schemaFieldName)
			}
			directive3 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "ID of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive2, label, description)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.ID = data
			} else if tmp == nil {
				it.ID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "make":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("make"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "update")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "update_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive1, resource, action, route, schemaFieldName)
			}
			directive3 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Make")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Text of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive2, label, description)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Make = data
			} else if tmp == nil {
				it.Make = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "done":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("done"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOBoolean2ᚖbool(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "update")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "update_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive1, resource, action, route, schemaFieldName)
			}
			directive3 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Done")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Done of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive2, label, description)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*bool); ok {
				it.Done = data
			} else if tmp == nil {
				it.Done = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "user":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "update")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "update_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive1, resource, action, route, schemaFieldName)
			}
			directive3 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "User")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "User of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive2, label, description)
			}

			tmp, err := directive3(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.User = data
			} else if tmp == nil {
				it.User = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteUsers(ctx context.Context, obj interface{}) (DeleteUsers, error) {
	var it DeleteUsers
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚕintᚄ(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BATCH_DELETE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "delete")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "delete_users")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "IDs")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "IDs of users")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]int); ok {
				it.Ids = data
			} else if tmp == nil {
				it.Ids = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListCars(ctx context.Context, obj interface{}) (ListCars, error) {
	var it ListCars
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "userId", "make"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "list_cars")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.ID = data
			} else if tmp == nil {
				it.ID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "list_cars")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "User ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "User ID")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.UserID = data
			} else if tmp == nil {
				it.UserID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "make":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("make"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "list_cars")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Make")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Make")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Make = data
			} else if tmp == nil {
				it.Make = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputListUser(ctx context.Context, obj interface{}) (ListUser, error) {
	var it ListUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOID2ᚖint(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "list_user")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "ID")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*int); ok {
				it.ID = data
			} else if tmp == nil {
				it.ID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx, "BROWSE_QUERY")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "list")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "list_user")
				if err != nil {
					return nil, err
				}
				if ec.directives.ListAction == nil {
					return nil, errors.New("directive ListAction is not implemented")
				}
				return ec.directives.ListAction(ctx, obj, directive0, resource, action, route, nil, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Name")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Name")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUser(ctx context.Context, obj interface{}) (NewUser, error) {
	var it NewUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_user")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Name")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Name")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive1, label, description)
			}

			tmp, err := directive2(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.Name = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "cars":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cars"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOCarInput2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInputᚄ(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive0, resource, action, route, schemaFieldName)
			}
			directive2 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "car")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "UPDATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "update")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "update_car")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive1, resource, action, route, schemaFieldName)
			}
			directive3 := func(ctx context.Context) (interface{}, error) {
				resource, err := ec.unmarshalNString2string(ctx, "user")
				if err != nil {
					return nil, err
				}
				action, err := ec.unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx, "CREATE_MUTATION")
				if err != nil {
					return nil, err
				}
				route, err := ec.unmarshalOString2ᚖstring(ctx, "new")
				if err != nil {
					return nil, err
				}
				schemaFieldName, err := ec.unmarshalOString2ᚖstring(ctx, "new_user")
				if err != nil {
					return nil, err
				}
				if ec.directives.Action == nil {
					return nil, errors.New("directive Action is not implemented")
				}
				return ec.directives.Action(ctx, obj, directive2, resource, action, route, schemaFieldName)
			}
			directive4 := func(ctx context.Context) (interface{}, error) {
				label, err := ec.unmarshalOString2ᚖstring(ctx, "Cars")
				if err != nil {
					return nil, err
				}
				description, err := ec.unmarshalOString2ᚖstring(ctx, "Cars of the todo")
				if err != nil {
					return nil, err
				}
				if ec.directives.ActionField == nil {
					return nil, errors.New("directive ActionField is not implemented")
				}
				return ec.directives.ActionField(ctx, obj, directive3, label, description)
			}

			tmp, err := directive4(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*CarInput); ok {
				it.Cars = data
			} else if tmp == nil {
				it.Cars = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/goxgen/goxgen/internal/integration/gormproj/generated.CarInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenCursorPaginationInput(ctx context.Context, obj interface{}) (XgenCursorPaginationInput, error) {
	var it XgenCursorPaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "after", "last", "before"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.First = data
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Last = data
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenPaginationInput(ctx context.Context, obj interface{}) (XgenPaginationInput, error) {
	var it XgenPaginationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenResourceDbConfigInput(ctx context.Context, obj interface{}) (XgenResourceDbConfigInput, error) {
	var it XgenResourceDbConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Table"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Table":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Table"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Table = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputXgenResourceFieldDbConfigInput(ctx context.Context, obj interface{}) (XgenResourceFieldDbConfigInput, error) {
	var it XgenResourceFieldDbConfigInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Column", "PrimaryKey", "AutoIncrement", "Unique", "NotNull", "Index", "UniqueIndex", "Size", "Precision", "Type", "Scale", "AutoIncrementIncrement"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Column":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Column"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Column = data
		case "PrimaryKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("PrimaryKey"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrimaryKey = data
		case "AutoIncrement":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AutoIncrement"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoIncrement = data
		case "Unique":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Unique"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unique = data
		case "NotNull":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NotNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotNull = data
		case "Index":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Index"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Index = data
		case "UniqueIndex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("UniqueIndex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UniqueIndex = data
		case "Size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Size"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "Precision":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Precision"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Precision = data
		case "Type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "Scale":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Scale"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scale = data
		case "AutoIncrementIncrement":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AutoIncrementIncrement"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoIncrementIncrement = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionImplementors = []string{"Action"}

func (ec *executionContext) _Action(ctx context.Context, sel ast.SelectionSet, obj *Action) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Action")
		case "Resource":
			out.Values[i] = ec._Action_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._Action_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._Action_Route(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._Action_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var actionAnnotationSingleImplementors = []string{"ActionAnnotationSingle"}

func (ec *executionContext) _ActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ActionAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionAnnotationSingle")
		case "name":
			out.Values[i] = ec._ActionAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ActionAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var actionFieldImplementors = []string{"ActionField"}

func (ec *executionContext) _ActionField(ctx context.Context, sel ast.SelectionSet, obj *ActionField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionField")
		case "Label":
			out.Values[i] = ec._ActionField_Label(ctx, field, obj)
		case "Description":
			out.Values[i] = ec._ActionField_Description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var carImplementors = []string{"Car"}

func (ec *executionContext) _Car(ctx context.Context, sel ast.SelectionSet, obj *Car) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, carImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Car")
		case "id":
			out.Values[i] = ec._Car_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "make":
			out.Values[i] = ec._Car_make(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "done":
			out.Values[i] = ec._Car_done(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._Car_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var carInputXgenDefImplementors = []string{"CarInputXgenDef"}

func (ec *executionContext) _CarInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *CarInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, carInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CarInputXgenDef")
		case "object":
			out.Values[i] = ec._CarInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._CarInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var carXgenDefImplementors = []string{"CarXgenDef"}

func (ec *executionContext) _CarXgenDef(ctx context.Context, sel ast.SelectionSet, obj *CarXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, carXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CarXgenDef")
		case "object":
			out.Values[i] = ec._CarXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._CarXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteUsersXgenDefImplementors = []string{"DeleteUsersXgenDef"}

func (ec *executionContext) _DeleteUsersXgenDef(ctx context.Context, sel ast.SelectionSet, obj *DeleteUsersXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteUsersXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteUsersXgenDef")
		case "object":
			out.Values[i] = ec._DeleteUsersXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._DeleteUsersXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fieldImplementors = []string{"Field"}

func (ec *executionContext) _Field(ctx context.Context, sel ast.SelectionSet, obj *Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Field")
		case "Label":
			out.Values[i] = ec._Field_Label(ctx, field, obj)
		case "Description":
			out.Values[i] = ec._Field_Description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listActionImplementors = []string{"ListAction"}

func (ec *executionContext) _ListAction(ctx context.Context, sel ast.SelectionSet, obj *ListAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListAction")
		case "Resource":
			out.Values[i] = ec._ListAction_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._ListAction_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._ListAction_Route(ctx, field, obj)
		case "Pagination":
			out.Values[i] = ec._ListAction_Pagination(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._ListAction_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listActionAnnotationSingleImplementors = []string{"ListActionAnnotationSingle"}

func (ec *executionContext) _ListActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ListActionAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listActionAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListActionAnnotationSingle")
		case "name":
			out.Values[i] = ec._ListActionAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ListActionAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listCarsXgenDefImplementors = []string{"ListCarsXgenDef"}

func (ec *executionContext) _ListCarsXgenDef(ctx context.Context, sel ast.SelectionSet, obj *ListCarsXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listCarsXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListCarsXgenDef")
		case "object":
			out.Values[i] = ec._ListCarsXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._ListCarsXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var listUserXgenDefImplementors = []string{"ListUserXgenDef"}

func (ec *executionContext) _ListUserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *ListUserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, listUserXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListUserXgenDef")
		case "object":
			out.Values[i] = ec._ListUserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._ListUserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "delete_users":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_delete_users(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "new_user":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_new_user(ctx, field)
			})
		case "new_car":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_new_car(ctx, field)
			})
		case "update_car":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_update_car(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newUserXgenDefImplementors = []string{"NewUserXgenDef"}

func (ec *executionContext) _NewUserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *NewUserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newUserXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewUserXgenDef")
		case "object":
			out.Values[i] = ec._NewUserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._NewUserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "_xgen_introspection":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__xgen_introspection(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "list_user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_list_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "list_cars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_list_cars(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceImplementors = []string{"Resource"}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj *Resource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resource")
		case "Name":
			out.Values[i] = ec._Resource_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._Resource_Route(ctx, field, obj)
		case "Primary":
			out.Values[i] = ec._Resource_Primary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceAnnotationSingleImplementors = []string{"ResourceAnnotationSingle"}

func (ec *executionContext) _ResourceAnnotationSingle(ctx context.Context, sel ast.SelectionSet, obj *ResourceAnnotationSingle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceAnnotationSingleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceAnnotationSingle")
		case "name":
			out.Values[i] = ec._ResourceAnnotationSingle_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._ResourceAnnotationSingle_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cars":
			out.Values[i] = ec._User_cars(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userXgenDefImplementors = []string{"UserXgenDef"}

func (ec *executionContext) _UserXgenDef(ctx context.Context, sel ast.SelectionSet, obj *UserXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserXgenDef")
		case "object":
			out.Values[i] = ec._UserXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._UserXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenAnnotationMapImplementors = []string{"XgenAnnotationMap"}

func (ec *executionContext) _XgenAnnotationMap(ctx context.Context, sel ast.SelectionSet, obj *XgenAnnotationMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenAnnotationMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenAnnotationMap")
		case "Action":
			out.Values[i] = ec._XgenAnnotationMap_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Resource":
			out.Values[i] = ec._XgenAnnotationMap_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ListAction":
			out.Values[i] = ec._XgenAnnotationMap_ListAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenCursorPaginationInputXgenDefImplementors = []string{"XgenCursorPaginationInputXgenDef"}

func (ec *executionContext) _XgenCursorPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenCursorPaginationInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenCursorPaginationInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenCursorPaginationInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenCursorPaginationInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenCursorPaginationInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenFieldDefImplementors = []string{"XgenFieldDef"}

func (ec *executionContext) _XgenFieldDef(ctx context.Context, sel ast.SelectionSet, obj *XgenFieldDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenFieldDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenFieldDef")
		case "Field":
			out.Values[i] = ec._XgenFieldDef_Field(ctx, field, obj)
		case "ActionField":
			out.Values[i] = ec._XgenFieldDef_ActionField(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenIntrospectionImplementors = []string{"XgenIntrospection"}

func (ec *executionContext) _XgenIntrospection(ctx context.Context, sel ast.SelectionSet, obj *XgenIntrospection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenIntrospectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenIntrospection")
		case "annotation":
			out.Values[i] = ec._XgenIntrospection_annotation(ctx, field, obj)
		case "object":
			out.Values[i] = ec._XgenIntrospection_object(ctx, field, obj)
		case "resource":
			out.Values[i] = ec._XgenIntrospection_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectDefinitionImplementors = []string{"XgenObjectDefinition"}

func (ec *executionContext) _XgenObjectDefinition(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectDefinition")
		case "Resource":
			out.Values[i] = ec._XgenObjectDefinition_Resource(ctx, field, obj)
		case "ListAction":
			out.Values[i] = ec._XgenObjectDefinition_ListAction(ctx, field, obj)
		case "Action":
			out.Values[i] = ec._XgenObjectDefinition_Action(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectFieldImplementors = []string{"XgenObjectField"}

func (ec *executionContext) _XgenObjectField(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectField")
		case "name":
			out.Values[i] = ec._XgenObjectField_name(ctx, field, obj)
		case "definition":
			out.Values[i] = ec._XgenObjectField_definition(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenObjectMapImplementors = []string{"XgenObjectMap"}

func (ec *executionContext) _XgenObjectMap(ctx context.Context, sel ast.SelectionSet, obj *XgenObjectMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenObjectMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenObjectMap")
		case "XgenResourceListActionType":
			out.Values[i] = ec._XgenObjectMap_XgenResourceListActionType(ctx, field, obj)
		case "Car":
			out.Values[i] = ec._XgenObjectMap_Car(ctx, field, obj)
		case "CarInput":
			out.Values[i] = ec._XgenObjectMap_CarInput(ctx, field, obj)
		case "XgenResourceActionType":
			out.Values[i] = ec._XgenObjectMap_XgenResourceActionType(ctx, field, obj)
		case "ListCars":
			out.Values[i] = ec._XgenObjectMap_ListCars(ctx, field, obj)
		case "XgenResourceFieldDbConfigInput":
			out.Values[i] = ec._XgenObjectMap_XgenResourceFieldDbConfigInput(ctx, field, obj)
		case "XgenCursorPaginationInput":
			out.Values[i] = ec._XgenObjectMap_XgenCursorPaginationInput(ctx, field, obj)
		case "DeleteUsers":
			out.Values[i] = ec._XgenObjectMap_DeleteUsers(ctx, field, obj)
		case "User":
			out.Values[i] = ec._XgenObjectMap_User(ctx, field, obj)
		case "NewUser":
			out.Values[i] = ec._XgenObjectMap_NewUser(ctx, field, obj)
		case "ListUser":
			out.Values[i] = ec._XgenObjectMap_ListUser(ctx, field, obj)
		case "XgenPaginationInput":
			out.Values[i] = ec._XgenObjectMap_XgenPaginationInput(ctx, field, obj)
		case "XgenResourceDbConfigInput":
			out.Values[i] = ec._XgenObjectMap_XgenResourceDbConfigInput(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenPaginationInputXgenDefImplementors = []string{"XgenPaginationInputXgenDef"}

func (ec *executionContext) _XgenPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenPaginationInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenPaginationInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenPaginationInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenPaginationInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenPaginationInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceActionImplementors = []string{"XgenResourceAction"}

func (ec *executionContext) _XgenResourceAction(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceAction")
		case "Resource":
			out.Values[i] = ec._XgenResourceAction_Resource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Action":
			out.Values[i] = ec._XgenResourceAction_Action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._XgenResourceAction_Route(ctx, field, obj)
		case "SchemaFieldName":
			out.Values[i] = ec._XgenResourceAction_SchemaFieldName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceActionTypeXgenDefImplementors = []string{"XgenResourceActionTypeXgenDef"}

func (ec *executionContext) _XgenResourceActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceActionTypeXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceActionTypeXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceActionTypeXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceActionTypeXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceActionTypeXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceDbConfigInputXgenDefImplementors = []string{"XgenResourceDbConfigInputXgenDef"}

func (ec *executionContext) _XgenResourceDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceDbConfigInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceDbConfigInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceDbConfigInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceDbConfigInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceDbConfigInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceDefinitionImplementors = []string{"XgenResourceDefinition"}

func (ec *executionContext) _XgenResourceDefinition(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceDefinitionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceDefinition")
		case "objectName":
			out.Values[i] = ec._XgenResourceDefinition_objectName(ctx, field, obj)
		case "properties":
			out.Values[i] = ec._XgenResourceDefinition_properties(ctx, field, obj)
		case "actions":
			out.Values[i] = ec._XgenResourceDefinition_actions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceFieldDbConfigInputXgenDefImplementors = []string{"XgenResourceFieldDbConfigInputXgenDef"}

func (ec *executionContext) _XgenResourceFieldDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceFieldDbConfigInputXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceFieldDbConfigInputXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceFieldDbConfigInputXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceFieldDbConfigInputXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceFieldDbConfigInputXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceListActionTypeXgenDefImplementors = []string{"XgenResourceListActionTypeXgenDef"}

func (ec *executionContext) _XgenResourceListActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceListActionTypeXgenDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceListActionTypeXgenDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceListActionTypeXgenDef")
		case "object":
			out.Values[i] = ec._XgenResourceListActionTypeXgenDef_object(ctx, field, obj)
		case "field":
			out.Values[i] = ec._XgenResourceListActionTypeXgenDef_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourceMapImplementors = []string{"XgenResourceMap"}

func (ec *executionContext) _XgenResourceMap(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourceMapImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceMap")
		case "car":
			out.Values[i] = ec._XgenResourceMap_car(ctx, field, obj)
		case "user":
			out.Values[i] = ec._XgenResourceMap_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var xgenResourcePropertyImplementors = []string{"XgenResourceProperty"}

func (ec *executionContext) _XgenResourceProperty(ctx context.Context, sel ast.SelectionSet, obj *XgenResourceProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, xgenResourcePropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("XgenResourceProperty")
		case "Name":
			out.Values[i] = ec._XgenResourceProperty_Name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Route":
			out.Values[i] = ec._XgenResourceProperty_Route(ctx, field, obj)
		case "Primary":
			out.Values[i] = ec._XgenResourceProperty_Primary(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ActionAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ActionAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ActionAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCar2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx context.Context, sel ast.SelectionSet, v []*Car) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCar2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarᚄ(ctx context.Context, sel ast.SelectionSet, v []*Car) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx context.Context, sel ast.SelectionSet, v *Car) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Car(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCarInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInput(ctx context.Context, v interface{}) (*CarInput, error) {
	res, err := ec.unmarshalInputCarInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNListActionAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListActionAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ListActionAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNListActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListActionAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNListActionAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListActionAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ListActionAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ListActionAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceAnnotationSingle2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResourceAnnotationSingleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ResourceAnnotationSingle) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResourceAnnotationSingle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceAnnotationSingle2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResourceAnnotationSingle(ctx context.Context, sel ast.SelectionSet, v *ResourceAnnotationSingle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceAnnotationSingle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNXgenObjectField2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []*XgenObjectField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNXgenObjectField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNXgenObjectField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectField(ctx context.Context, sel ast.SelectionSet, v *XgenObjectField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._XgenObjectField(ctx, sel, v)
}

func (ec *executionContext) marshalNXgenResourceAction2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceAction(ctx context.Context, sel ast.SelectionSet, v []*XgenResourceAction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOXgenResourceAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceAction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx context.Context, v interface{}) (XgenResourceActionType, error) {
	var res XgenResourceActionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNXgenResourceActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionType(ctx context.Context, sel ast.SelectionSet, v XgenResourceActionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx context.Context, v interface{}) (XgenResourceListActionType, error) {
	var res XgenResourceListActionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNXgenResourceListActionType2githubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionType(ctx context.Context, sel ast.SelectionSet, v XgenResourceListActionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐAction(ctx context.Context, sel ast.SelectionSet, v *Action) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Action(ctx, sel, v)
}

func (ec *executionContext) marshalOActionField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐActionField(ctx context.Context, sel ast.SelectionSet, v *ActionField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ActionField(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCar2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCar(ctx context.Context, sel ast.SelectionSet, v *Car) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Car(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCarInput2ᚕᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInputᚄ(ctx context.Context, v interface{}) ([]*CarInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*CarInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCarInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCarInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInput(ctx context.Context, v interface{}) (*CarInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCarInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCarInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *CarInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CarInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOCarXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐCarXgenDef(ctx context.Context, sel ast.SelectionSet, v *CarXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CarXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalODeleteUsers2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐDeleteUsers(ctx context.Context, v interface{}) (*DeleteUsers, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteUsers(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeleteUsersXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐDeleteUsersXgenDef(ctx context.Context, sel ast.SelectionSet, v *DeleteUsersXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteUsersXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOField2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐField(ctx context.Context, sel ast.SelectionSet, v *Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Field(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOListAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListAction(ctx context.Context, sel ast.SelectionSet, v *ListAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListAction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListCars2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListCars(ctx context.Context, v interface{}) (*ListCars, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListCars(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOListCarsXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListCarsXgenDef(ctx context.Context, sel ast.SelectionSet, v *ListCarsXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListCarsXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOListUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListUser(ctx context.Context, v interface{}) (*ListUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputListUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOListUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐListUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *ListUserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListUserXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalONewUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐNewUser(ctx context.Context, v interface{}) (*NewUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNewUser(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONewUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐNewUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *NewUserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NewUserXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOResource2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐResource(ctx context.Context, sel ast.SelectionSet, v *Resource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐUserXgenDef(ctx context.Context, sel ast.SelectionSet, v *UserXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenAnnotationMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenAnnotationMap(ctx context.Context, sel ast.SelectionSet, v *XgenAnnotationMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenAnnotationMap(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenCursorPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenCursorPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenCursorPaginationInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenCursorPaginationInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenFieldDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenFieldDef(ctx context.Context, sel ast.SelectionSet, v *XgenFieldDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenFieldDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenIntrospection2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenIntrospection(ctx context.Context, sel ast.SelectionSet, v *XgenIntrospection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenIntrospection(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenObjectDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectDefinition(ctx context.Context, sel ast.SelectionSet, v *XgenObjectDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenObjectDefinition(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenObjectMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenObjectMap(ctx context.Context, sel ast.SelectionSet, v *XgenObjectMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenObjectMap(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenPaginationInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenPaginationInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenPaginationInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenPaginationInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceAction2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceAction(ctx context.Context, sel ast.SelectionSet, v *XgenResourceAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceAction(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceActionTypeXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceActionTypeXgenDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOXgenResourceDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInput(ctx context.Context, v interface{}) (*XgenResourceDbConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputXgenResourceDbConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOXgenResourceDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceDbConfigInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceDbConfigInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceDefinition2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceDefinition(ctx context.Context, sel ast.SelectionSet, v *XgenResourceDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceDefinition(ctx, sel, v)
}

func (ec *executionContext) unmarshalOXgenResourceFieldDbConfigInput2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInput(ctx context.Context, v interface{}) (*XgenResourceFieldDbConfigInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputXgenResourceFieldDbConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOXgenResourceFieldDbConfigInputXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceFieldDbConfigInputXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceFieldDbConfigInputXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceFieldDbConfigInputXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceListActionTypeXgenDef2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceListActionTypeXgenDef(ctx context.Context, sel ast.SelectionSet, v *XgenResourceListActionTypeXgenDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceListActionTypeXgenDef(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceMap2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceMap(ctx context.Context, sel ast.SelectionSet, v *XgenResourceMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceMap(ctx, sel, v)
}

func (ec *executionContext) marshalOXgenResourceProperty2ᚖgithubᚗcomᚋgoxgenᚋgoxgenᚋinternalᚋintegrationᚋgormprojᚋgeneratedᚐXgenResourceProperty(ctx context.Context, sel ast.SelectionSet, v *XgenResourceProperty) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._XgenResourceProperty(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
